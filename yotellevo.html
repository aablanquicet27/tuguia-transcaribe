<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¬°Yo te llevo! - Tuguia</title>
    <style>
        body {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            padding: 2rem 0;
        }
        
        .main-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            gap: 1rem;
        }
        
        .container {
            background: white;
            border-radius: 22px;
            box-shadow: 0 8px 32px rgba(107,70,193,0.10);
            padding: 2.5rem 2rem 2rem 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        .title {
            font-size: 2rem;
            color: #6b46c1;
            font-weight: 700;
            margin-bottom: 1.2rem;
            letter-spacing: 0.5px;
        }
        .subtitle {
            font-size: 1.1rem;
            color: #4a5568;
            margin-bottom: 2.2rem;
            font-weight: 400;
        }
        .big-icon {
            font-size: 3.5rem;
            margin-bottom: 1.2rem;
            color: #ff6600;
        }
        .main-btn {
            background: linear-gradient(135deg, #6b46c1, #553c9a);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.9rem 2.2rem;
            box-shadow: 0 6px 20px rgba(107,70,193,0.13);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            letter-spacing: 0.5px;
            margin-top: 1.5rem;
        }
        .main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 32px rgba(107,70,193,0.18);
        }
        .info-section {
            margin-top: 1.5rem;
            text-align: left;
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-section ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .info-section li {
            margin-bottom: 0.5rem;
        }
        .footer-agapai {
            width: 100vw;
            text-align: center;
            padding: 1.2em 0 0.7em 0;
            font-size: 10px;
            color: #6b46c1;
            font-weight: 400;
            letter-spacing: 0.5px;
            position: fixed;
            left: 0;
            bottom: 0;
            background: transparent;
            z-index: 100;
        }
        .footer-agapai a {
            color: #ff6600;
            text-decoration: none;
            font-weight: 400;
        }
        @media (max-width: 600px) {
            .footer-agapai { font-size: 0.95em; padding-bottom: 0.5em; }
        }
        
        /* Estilos para los contenedores de mapas */
        .map-container {
            background: white;
            border-radius: 18px;
            box-shadow: 0 6px 24px rgba(107,70,193,0.08);
            padding: 1.8rem;
            margin: 1rem auto;
            max-width: 600px;
            width: 90%;
        }
        
        .map-title {
            font-size: 1.3rem;
            color: #6b46c1;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
            letter-spacing: 0.3px;
        }
        
        .map-subtitle {
            font-size: 0.9rem;
            color: #718096;
            font-weight: 400;
            margin-bottom: 1.2rem;
            text-align: center;
            font-style: italic;
        }
        
        .map-area {
            height: 400px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            border: 1px solid #e2e8f0;
        }
        @media (max-width: 768px) {
            .map-area {
                height: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="container">
            <div class="big-icon">üß≠</div>
            <div class="title" style="display:flex;align-items:center;gap:12px;justify-content:center;">
              <div style="display:flex;align-items:center;gap:12px;background:#f3f0ff;border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.10);padding:16px 32px;border:4px solid #d1c4e9;">
                <img src="logoagapai-ok2.png" alt="Logo Agapai" style="height:56px;width:auto;vertical-align:middle;display:inline-block;" />
                <span style="font-family:'Segoe UI',Arial,sans-serif;font-size:2rem;color:#6b46c1;font-weight:700;letter-spacing:0.5px;">¬°Yo te llevo!</span>
              </div>
            </div>
            <div class="subtitle">¬øNo sabes c√≥mo llegar a tu destino?<br>D√©jalo en mis manos, te ayudo a encontrar la mejor ruta y te acompa√±o en el camino.</div>
            <!-- Panel de paraderos cercanos al destino -->
            <div id="info-paraderos" class="info-section"></div>
            <!-- Panel Tu Gu√≠a Inteligente (nuevo contenedor) -->
            <div id="panel-guia-inteligente"></div>
            <div id="info-ruta" class="info-section"></div>
            <!-- Reemplaza el enlace por un bot√≥n funcional para volver a la gu√≠a -->
            <button id="volverAGuiaBtn" class="main-btn">Volver a Tu Gu√≠a</button>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DE PARTIDA -->
        <div class="map-container">
            <h3 class="map-title">üó∫Ô∏è Paraderos cercanos a tu Punto de Partida</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>üìç Tu ubicaci√≥n</span>
              <span>üéØ Tu destino</span>
              <span>üöå Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-origen" class="map-area"></div>
            <div id="mensaje-error-mapa-origen" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DESTINO -->
        <div class="map-container">
            <h3 class="map-title">üéØ Paraderos cercanos a tu Punto Destino</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>üìç Tu ubicaci√≥n</span>
              <span>üéØ Tu destino</span>
              <span>üöå Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-destino" class="map-area"></div>
            <div id="mensaje-error-mapa-destino" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
    </div>
    
    <!-- Modal de alerta de proximidad -->
    <div id="modal-proximidad" style="display:none;position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);justify-content:center;align-items:center;">
      <div style="background:#fffbe6;border:4px solid #ff9800;border-radius:18px;padding:2em 2em 1.5em 2em;box-shadow:0 8px 32px #0008;text-align:center;max-width:90vw;">
        <div style="font-size:2.2em;color:#ff9800;font-weight:bold;margin-bottom:0.5em;">¬°Atenci√≥n!</div>
        <div style="font-size:1.3em;color:#333;margin-bottom:1em;">Faltan menos de <b>300 metros</b> para llegar a tu destino.<br>Prep√°rate para descender.</div>
        <button id="btnAlertaEntendido" style="font-size:1.1em;padding:0.5em 1.5em;background:#ff9800;color:#fff;border:none;border-radius:8px;cursor:pointer;">Entendido</button>
      </div>
    </div>
    <footer class="footer-agapai">
        Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
    </footer>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline"></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
    <script>
    // =================== L√ìGICA DE NAVEGACI√ìN INTELIGENTE ===================
    
    // Variables globales para el seguimiento inteligente
    let isIntelligentTrackingActive = false;
    let intelligentTrackingWatchId = null;
    let intelligentTrackingStartTime = null;
    let intelligentTrackingLastPosition = null;
    let intelligentTrackingDistance = 0;
    let intelligentTrackingAlarmaActivada = false;
    let intelligentTrackingDestino = null;
    let rutaOptimaCalculada = null;
    let paraderoCercanoEncontrado = null;
    
    // Variables globales para alarma/vibraci√≥n
    let alarmaFinalInterval = null;
    
    // Utilidad para calcular distancia entre dos puntos (Haversine)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Radio de la Tierra en metros
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Funci√≥n para obtener ubicaci√≥n GPS
    function obtenerUbicacionGPS() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocalizaci√≥n no soportada'));
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            resolve({
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              accuracy: pos.coords.accuracy
            });
          },
          (error) => {
            reject(new Error(`Error de geolocalizaci√≥n: ${error.message}`));
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      });
    }
    
    // Funci√≥n para geocodificaci√≥n inversa (coordenadas a direcci√≥n)
    async function obtenerDireccionDesdeCoordenadas(lat, lng) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
        const data = await response.json();
        if (data && data.address) {
          return data; // Devolver el objeto completo
        }
        return null;
      } catch (error) {
        console.error('‚ùå Error en geocodificaci√≥n inversa:', error);
        return null;
      }
    }
    
    // Funci√≥n para encontrar paradero m√°s cercano
    async function encontrarParaderoMasCercano(ubicacionUsuario) {
      if (!window.rutasTranscaribe || !Array.isArray(window.rutasTranscaribe)) {
        console.error('‚ùå No hay datos de paraderos disponibles');
        return null;
      }
      
      console.log('üîç === BUSCANDO PARADERO M√ÅS CERCANO ===');
      console.log('üìç Ubicaci√≥n usuario:', ubicacionUsuario);
      console.log('üìä Total de features en GeoJSON:', window.rutasTranscaribe.length);
      
      let paraderoMasCercano = null;
      let distanciaMinima = Infinity;
      
      // Filtrar solo paraderos Transcaribe
      const paraderosTranscaribe = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      console.log('üöå Paraderos Transcaribe encontrados:', paraderosTranscaribe.length);
      
      paraderosTranscaribe.forEach((paradero, index) => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const distancia = haversine(
          ubicacionUsuario.lat, ubicacionUsuario.lng,
          lat, lon
        );
        
        // Log del primer paradero para debugging
        if (index === 0) {
          console.log('üîç Ejemplo de paradero:', {
            nombre: paradero.properties.nombre_paradero,
            rutas: paradero.properties.rutas,
            network: paradero.properties.network,
            distancia: distancia
          });
        }
        
        if (distancia < distanciaMinima) {
          distanciaMinima = distancia;
          paraderoMasCercano = {
            nombre: paradero.properties.nombre_paradero || 'Paradero',
            lat: lat,
            lon: lon,
            distancia: distancia,
            rutas: paradero.properties.rutas || '',
            tipos_ruta: paradero.properties.tipos_ruta || ''
          };
        }
      });
      
      console.log('üìç Paradero m√°s cercano encontrado:', paraderoMasCercano);
      return paraderoMasCercano;
    }
    
    // Funci√≥n para verificar ruta directa
    function verificarRutaDirecta(paraderoOrigen, paraderoDestino) {
      console.log('üîç === VERIFICANDO RUTA DIRECTA ===');
      console.log('üìç Paradero Origen:', paraderoOrigen);
      console.log('üéØ Paradero Destino:', paraderoDestino);
      // Convertir rutas de string a array si es necesario
      const rutasOrigen = typeof paraderoOrigen.rutas === 'string' ? 
        paraderoOrigen.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoOrigen.rutas) ? paraderoOrigen.rutas : []);
      const rutasDestino = typeof paraderoDestino.rutas === 'string' ? 
        paraderoDestino.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoDestino.rutas) ? paraderoDestino.rutas : []);
      console.log('üöå Rutas Origen (procesadas):', rutasOrigen);
      console.log('üöå Rutas Destino (procesadas):', rutasDestino);
      // Buscar intersecci√≥n
      const rutasComunes = rutasOrigen.filter(ruta => rutasDestino.includes(ruta));
      console.log('üü¢ Rutas comunes (intersecci√≥n):', rutasComunes);
      if (rutasComunes.length > 0) {
        console.log('‚úÖ Ruta directa encontrada:', rutasComunes[0]);
        return { ruta: rutasComunes[0], todas: rutasComunes };
      }
      console.log('‚ùå No se encontr√≥ ruta directa');
      return null;
    }
    
    // Funci√≥n para encontrar mejor transbordo
    function encontrarMejorTransbordo(paraderoOrigen, paraderoDestino) {
      if (!window.rutasTranscaribe) return null;
      
      // Buscar paraderos que conecten las rutas
      const paraderosTransbordo = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      let mejorTransbordo = null;
      let mejorScore = Infinity;
      
      paraderosTransbordo.forEach(paradero => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const rutasParadero = typeof paradero.properties.rutas === 'string' ? 
          paradero.properties.rutas.split(',').map(r => r.trim()) : 
          (Array.isArray(paradero.properties.rutas) ? paradero.properties.rutas : []);
        
        // Verificar si este paradero conecta origen y destino
        const rutaDesdeOrigen = verificarRutaDirecta(paraderoOrigen, {
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        });
        
        const rutaHastaDestino = verificarRutaDirecta({
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        }, paraderoDestino);
        
        if (rutaDesdeOrigen && rutaHastaDestino) {
          // Calcular score basado en distancia total
          const distOrigenTransbordo = haversine(
            paraderoOrigen.lat, paraderoOrigen.lon,
            lat, lon
          );
          
          const distTransbordoDestino = haversine(
            lat, lon,
            paraderoDestino.lat, paraderoDestino.lon
          );
          
          const score = distOrigenTransbordo + distTransbordoDestino;
          
          if (score < mejorScore) {
            mejorScore = score;
            mejorTransbordo = {
              paraderoTransbordo: {
                nombre: paradero.properties.nombre_paradero,
                lat: lat,
                lon: lon
              },
              ruta1: rutaDesdeOrigen.ruta,
              ruta2: rutaHastaDestino.ruta,
              score: score
            };
          }
        }
      });
      
      return mejorTransbordo;
    }
    
    // Funci√≥n para calcular ruta √≥ptima
    async function calcularRutaOptima(paraderoOrigen, destinoCoords) {
      if (!destinoCoords) {
        console.error('‚ùå No hay coordenadas de destino');
        return null;
      }
      // Buscar paradero m√°s cercano al destino
      const paraderoDestino = await encontrarParaderoMasCercano({
        lat: destinoCoords[0],
        lng: destinoCoords[1]
      });
      if (!paraderoDestino) {
        console.error('‚ùå No se encontr√≥ paradero cercano al destino');
        return null;
      }
      // Verificar si hay ruta directa
      const rutaDirecta = verificarRutaDirecta(paraderoOrigen, paraderoDestino);
      console.log('üü¢ Resultado de verificarRutaDirecta:', rutaDirecta);
      // Obtener el nombre filtrado del destino para la comparaci√≥n
      let destinoNombreOriginal = (typeof end === 'string') ? end : (paraderoDestino.nombre || '');
      // --- CORRECCI√ìN CLAVE ---
      // Si destinoNombreOriginal es un JSON, extraer solo el campo 'nombre' si existe
      try {
        if (typeof destinoNombreOriginal === 'string' && destinoNombreOriginal.trim().startsWith('{')) {
          const obj = JSON.parse(destinoNombreOriginal);
          if (obj && obj.nombre) {
            destinoNombreOriginal = obj.nombre;
          } else if (obj && obj.display_name) {
            destinoNombreOriginal = obj.display_name;
          } else {
            destinoNombreOriginal = '';
          }
        }
      } catch (e) {
        // Si falla el parseo, dejar el valor como est√°
      }
      // Asegura que destinoNombreOriginal sea un string legible
      if (typeof destinoNombreOriginal === 'object' && destinoNombreOriginal !== null) {
        if (destinoNombreOriginal.nombre) {
          destinoNombreOriginal = destinoNombreOriginal.nombre;
        } else if (destinoNombreOriginal.display_name) {
          destinoNombreOriginal = destinoNombreOriginal.display_name;
        } else {
          destinoNombreOriginal = '';
        }
      }
      // Normaliza nombres para comparaci√≥n robusta
      function normalizarTexto(str) {
        return String(str).toLowerCase().normalize('NFD').replace(/[0-\u036f]/g, '').trim();
      }
      const destinoNombreFiltrado = limpiarDireccionParaMostrar(destinoNombreOriginal);
      const nombreParadero = normalizarTexto(paraderoDestino.nombre);
      const nombreDestino = normalizarTexto(destinoNombreFiltrado);
      // Calcular distancia a pie entre el paradero y el destino
      let distanciaAPie = await obtenerDistanciaCaminando([paraderoDestino.lat, paraderoDestino.lon], destinoCoords);
      // --- AJUSTE CLAVE ---
      // Si el destino es una direcci√≥n escrita, siempre mostrar la caminata final
      if (rutaDirecta && rutaDirecta.todas && rutaDirecta.todas.length > 0) {
        let rutasTexto = rutaDirecta.todas.length === 1 ? `la ruta ${rutaDirecta.todas[0]}` : `las rutas ${rutaDirecta.todas.join(', ')}`;
        let mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevar√° directamente a ${paraderoDestino.nombre}.`;
        if (endMode !== 'paradero') {
          // Siempre mostrar caminata si el destino es direcci√≥n escrita
          mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevar√° directamente a ${paraderoDestino.nombre}, desde all√≠ te desplazas a pie ${Math.round(distanciaAPie)} metros para llegar a ${destinoNombreFiltrado}.`;
        } else if (Math.round(distanciaAPie) > 0 && nombreParadero !== nombreDestino) {
          // Solo para paradero, mostrar caminata si es necesario
          mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevar√° directamente a ${paraderoDestino.nombre}, desde all√≠ te desplazas a pie ${Math.round(distanciaAPie)} metros para llegar a ${destinoNombreFiltrado}.`;
        }
        return {
          tipo: 'directa',
          paraderoOrigen: paraderoOrigen,
          paraderoDestino: paraderoDestino,
          ruta: rutaDirecta.todas,
          mensaje: mensaje,
          pasos: rutaDirecta.todas.map(ruta => ({ accion: 'tomar', ruta: ruta, desde: paraderoOrigen, hasta: paraderoDestino }))
        };
      } else {
        // Buscar transbordo
        const transbordo = encontrarMejorTransbordo(paraderoOrigen, paraderoDestino);
        if (transbordo && transbordo.ruta1 && transbordo.ruta2) {
          const mensaje = `Toma la ruta ${transbordo.ruta1} hasta ${transbordo.paraderoTransbordo.nombre}. All√≠ cambia a la ruta ${transbordo.ruta2} hasta ${paraderoDestino.nombre}.`;
          return {
            tipo: 'con_transbordo',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            paraderoTransbordo: transbordo.paraderoTransbordo,
            ruta1: transbordo.ruta1,
            ruta2: transbordo.ruta2,
            mensaje: mensaje,
            pasos: [
              { accion: 'tomar', ruta: transbordo.ruta1, desde: paraderoOrigen, hasta: transbordo.paraderoTransbordo },
              { accion: 'transbordar', en: transbordo.paraderoTransbordo },
              { accion: 'tomar', ruta: transbordo.ruta2, desde: transbordo.paraderoTransbordo, hasta: paraderoDestino }
            ]
          };
        } else {
          // Si no hay ruta directa ni transbordo v√°lido, mostrar advertencia
          const mensaje = 'No se encontr√≥ una ruta directa ni con transbordo entre los paraderos seleccionados.';
          return {
            tipo: 'sin_ruta',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            mensaje: mensaje,
            pasos: []
          };
        }
      }
    }
    
    // Funci√≥n para mostrar instrucciones inteligentes
    function mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario) {
      let instruccionesHTML = `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 18px; padding: 1.7rem 1.3rem 1.3rem 1.3rem; margin: 1.2rem 0; box-shadow: 0 2px 16px rgba(44,62,80,0.10); color: #fff; max-width: 420px;">
          <h3 style="margin: 0 0 1.1rem 0; font-size: 1.35rem; color: #fff; font-weight: 700; letter-spacing: 0.5px;">üß† Tu Gu√≠a Inteligente</h3>
          <div style="margin-bottom: 1rem; font-size: 1.05rem; display: flex; align-items: center; gap: 8px;">
            <span style='font-size:1.2em;'>üìç</span> <strong>Tu ubicaci√≥n:</strong> <span style='color:#ffe082;'>${ubicacionUsuario.lat.toFixed(6)}, ${ubicacionUsuario.lng.toFixed(6)}</span>
          </div>
          <div style="margin-bottom: 1rem; font-size: 1.05rem; display: flex; align-items: center; gap: 8px;">
            <span style='font-size:1.2em;'>üöå</span> <strong>Paradero m√°s cercano:</strong> <span style='color:#ffe082;'>${paraderoCercano.nombre} (${Math.round(paraderoCercano.distancia)}m)</span>
          </div>
          <div style="background: rgba(255,255,255,0.18); color: #fff; padding: 1.1rem 1rem; border-radius: 12px; margin-bottom: 1.2rem; font-size: 1.07rem;">
            <strong style='display:flex;align-items:center;gap:7px;'><span style='font-size:1.2em;'>üìã</span> Instrucciones:</strong>
            <div style='margin-top:0.5em;'>${rutaOptima.mensaje}</div>
          </div>
          <button id="btnIniciarSeguimiento" style="background: linear-gradient(90deg, #ff6600 60%, #ff9800 100%); color: #fff; border: none; border-radius: 10px; padding: 0.85em 1.7em; font-size: 1.08em; font-weight: 600; cursor: pointer; box-shadow: 0 2px 8px rgba(255,102,0,0.13); display: flex; align-items: center; gap: 8px; margin: 0 auto;">
            <span style='font-size:1.2em;'>üöÄ</span> Iniciar Seguimiento Inteligente
          </button>
        </div>
      `;
      const panelGuia = document.getElementById('panel-guia-inteligente');
      if (panelGuia) {
        panelGuia.innerHTML = instruccionesHTML;
        // Asociar funcionalidad al bot√≥n
        const btn = document.getElementById('btnIniciarSeguimiento');
        if (btn) {
          btn.addEventListener('click', function() {
            iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario);
          });
        }
      }
      console.log('üìã Instrucciones inteligentes mostradas:', rutaOptima.mensaje);
    }
    
    // Funci√≥n para iniciar seguimiento inteligente
    function iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario) {
      if (isIntelligentTrackingActive) return;
      
      isIntelligentTrackingActive = true;
      intelligentTrackingDistance = 0;
      intelligentTrackingAlarmaActivada = false;
      intelligentTrackingStartTime = Date.now();
      intelligentTrackingLastPosition = null;
      intelligentTrackingDestino = [rutaOptima.paraderoDestino.lat, rutaOptima.paraderoDestino.lon];
      rutaOptimaCalculada = rutaOptima;
      paraderoCercanoEncontrado = paraderoCercano;
      
      // Crear panel de seguimiento
      const seguimientoHTML = `
        <div style="background: #fffbe6; border: 2.5px solid #bdbdbd; border-radius: 14px; padding: 1.5rem; margin: 1rem 0; box-shadow: 0 2px 12px rgba(0,0,0,0.07), 0 1.5px 6px rgba(189,189,189,0.10);">
          <h4 style="margin: 0 0 1rem 0; color: #007bff;">üöÄ Seguimiento Inteligente Activo</h4>
          <div style="background: #ffe9b3; color: #b26a00; border-radius: 8px; padding: 8px 0; margin-bottom: 12px; font-weight: 700; font-size: 1.13rem; text-align: center; box-shadow: 0 1px 4px rgba(33,136,56,0.07); letter-spacing: 0.5px;">
            <span style="display:inline-flex;align-items:center;gap:8px;">
              <span style="font-size:1.3em;">üü¢</span> ¬°Est√°s siendo guiado en tiempo real!
            </span>
          </div>
          <div id="leyenda-barrio" style="font-size:1.1em;color:#6b46c1;font-weight:600;margin-bottom:0.7em;"></div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
            <div>
              <strong>üìè Distancia recorrida:</strong><br>
              <span id="distanciaRecorrida">0.0 km</span>
            </div>
            <div>
              <strong>‚è±Ô∏è Tiempo transcurrido:</strong><br>
              <span id="tiempoTranscurrido">00:00</span>
            </div>
            <div>
              <strong>üö∂ Velocidad actual:</strong><br>
              <span id="velocidadActual">0.0 km/h</span>
            </div>
            <div>
              <strong>üìç Estado:</strong><br>
              <span id="estadoSeguimiento">üìç Iniciando...</span>
            </div>
          </div>
          <div style="background: #e9ecef; border-radius: 8px; padding: 0.5rem; margin-bottom: 1rem;">
            <div style="background: #007bff; height: 8px; border-radius: 4px; width: 0%; transition: width 0.3s;" id="barraProgreso"></div>
          </div>
          <button id="detenerSeguimientoBtn" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer;">
            ‚èπÔ∏è Detener Seguimiento
          </button>
        </div>
      `;
      
      // Reemplazar las instrucciones con el panel de seguimiento
      const infoElement = document.getElementById('info-ruta');
      if (infoElement) {
        infoElement.innerHTML = seguimientoHTML;
        
        // Agregar event listener al bot√≥n de detener
        setTimeout(() => {
          const btn = document.getElementById('detenerSeguimientoBtn');
          if (btn) {
            btn.addEventListener('click', detenerSeguimientoInteligente);
          }
        }, 100);
      }
      
      // Iniciar seguimiento de ubicaci√≥n
      if (intelligentTrackingWatchId) navigator.geolocation.clearWatch(intelligentTrackingWatchId);
      
      intelligentTrackingWatchId = navigator.geolocation.watchPosition(
        function(pos) {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const current = L.latLng(lat, lon);
          
          // Calcular distancia recorrida
          if (intelligentTrackingLastPosition) {
            const d = intelligentTrackingLastPosition.distanceTo(current);
            if (d > 2) { // Solo sumar si el movimiento es real (>2m)
              intelligentTrackingDistance += d;
            }
          }
          intelligentTrackingLastPosition = current;
          
          // Actualizar UI
          document.getElementById('distanciaRecorrida').textContent = (intelligentTrackingDistance / 1000).toFixed(2) + ' km';
          
          // Actualizar tiempo
          const elapsed = (Date.now() - intelligentTrackingStartTime) / 1000;
          const min = Math.floor(elapsed / 60);
          const sec = Math.floor(elapsed % 60);
          document.getElementById('tiempoTranscurrido').textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
          
          // Calcular velocidad
          const speedKmh = pos.coords.speed && pos.coords.speed > 0 ? (pos.coords.speed * 3.6) : (intelligentTrackingDistance / elapsed) * 3.6;
          document.getElementById('velocidadActual').textContent = speedKmh > 0 ? speedKmh.toFixed(1) + ' km/h' : '0.0 km/h';
          
          // Estado
          const estadoElement = document.getElementById('estadoSeguimiento');
          if (speedKmh > 0.5) {
            estadoElement.textContent = 'üü¢ En movimiento';
            estadoElement.style.color = '#28a745';
          } else {
            estadoElement.textContent = '‚è∏Ô∏è Detenido';
            estadoElement.style.color = '#dc3545';
          }
          
          // Barra de progreso
          if (intelligentTrackingDestino) {
            const distRestante = current.distanceTo(L.latLng(intelligentTrackingDestino[0], intelligentTrackingDestino[1]));
            let totalDist = intelligentTrackingDistance + distRestante;
            let progress = totalDist > 0 ? (intelligentTrackingDistance / totalDist) * 100 : 0;
            document.getElementById('barraProgreso').style.width = progress + '%';
            
            // Alarma a 300m
            if (!intelligentTrackingAlarmaActivada && distRestante <= 300 && distRestante > 30) {
              intelligentTrackingAlarmaActivada = true;
              mostrarAlertaProximidad();
            }
            // === NUEVO: Detener autom√°ticamente al llegar al destino ===
            if (distRestante <= 30 && isIntelligentTrackingActive) {
              detenerSeguimientoInteligente();
            }
          }
          
          // Actualizar leyenda de barrio
          obtenerDireccionDesdeCoordenadas(lat, lon).then(data => {
            let barrio = '';
            if (data && data.address) {
              barrio = data.address.suburb || data.address.neighbourhood || data.address.quarter || data.address.city_district || data.address.city || '';
              if (!barrio && data.display_name) {
                barrio = data.display_name.split(',')[0];
              }
            }
            document.getElementById('leyenda-barrio').textContent = barrio ? `Vamos Por: ${barrio}` : '';
          });
        },
        function(error) {
          console.error('Error en seguimiento inteligente:', error);
          document.getElementById('estadoSeguimiento').textContent = '‚ùå Error de GPS';
          document.getElementById('estadoSeguimiento').style.color = '#dc3545';
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        }
      );
      
      console.log('üöÄ Seguimiento inteligente iniciado');
    }
    
    // Funci√≥n para detener seguimiento inteligente
    function detenerSeguimientoInteligente() {
      if (intelligentTrackingWatchId) {
        navigator.geolocation.clearWatch(intelligentTrackingWatchId);
        intelligentTrackingWatchId = null;
      }
      
      isIntelligentTrackingActive = false;
      
      // Mostrar resumen con bot√≥n
      const resumenHTML = `
        <div style="background: #fffbe6; border: 2.5px solid #ff9800; border-radius: 12px; padding: 1.5rem; margin: 1rem 0;">
          <h4 style="margin: 0 0 1rem 0; color: #155724;">‚úÖ Recorrido Finalizado</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
              <strong>üìè Distancia total:</strong><br>
              <span>${(intelligentTrackingDistance / 1000).toFixed(2)} km</span>
            </div>
            <div>
              <strong>‚è±Ô∏è Tiempo total:</strong><br>
              <span>${document.getElementById('tiempoTranscurrido').textContent}</span>
            </div>
          </div>
          <button id="btnNuevoSeguimiento" style="background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; margin-top: 1rem;">
            üîÑ Iniciar Nuevo Seguimiento
          </button>
        </div>
      `;
      const infoElement = document.getElementById('info-ruta');
      if (infoElement) {
        infoElement.innerHTML = resumenHTML;
        // Activar alarma y vibraci√≥n muy molesta
        detenerAlarmaFinal(); // Por si acaso ya hay una activa
        alarmaFinalInterval = setInterval(() => {
          // Vibraci√≥n muy molesta: vibrar 1.2s, pausa 200ms, repetir 6 veces
          if (navigator.vibrate) navigator.vibrate([1200,200,1200,200,1200,200,1200,200,1200,200,1200]);
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'sine';
            o.frequency.value = 880;
            o.connect(g); g.connect(ctx.destination);
            g.gain.value = 0.2;
            o.start();
            setTimeout(()=>{g.gain.value=0; o.stop(); ctx.close();}, 500);
          } catch(e) {}
        }, 2200);
        // Bot√≥n para detener alarma y vibraci√≥n
        setTimeout(() => {
          const btn = document.getElementById('btnNuevoSeguimiento');
          if (btn) {
            btn.onclick = function() {
              detenerAlarmaFinal();
              window.location.reload();
            };
          }
        }, 100);
      }
    }
    
    function detenerAlarmaFinal() {
      if (alarmaFinalInterval) {
        clearInterval(alarmaFinalInterval);
        alarmaFinalInterval = null;
      }
      if (navigator.vibrate) navigator.vibrate(0);
    }
    
    // Funci√≥n principal de navegaci√≥n inteligente
    async function iniciarNavegacionInteligente(destinoCoords) {
      try {
        console.log('üß† Iniciando navegaci√≥n inteligente...');
        
        // 1. Obtener ubicaci√≥n GPS actual
        const ubicacionUsuario = await obtenerUbicacionGPS();
        if (!ubicacionUsuario) {
          console.error('‚ùå No se pudo obtener ubicaci√≥n GPS');
          return;
        }
        
        // 2. Encontrar paradero m√°s cercano autom√°ticamente
        const paraderoCercano = await encontrarParaderoMasCercano(ubicacionUsuario);
        if (!paraderoCercano) {
          console.error('‚ùå No se encontr√≥ paradero cercano');
          return;
        }
        
        // 3. Calcular ruta √≥ptima autom√°ticamente
        const rutaOptima = await calcularRutaOptima(paraderoCercano, destinoCoords);
        if (!rutaOptima) {
          console.error('‚ùå No se pudo calcular ruta √≥ptima');
          return;
        }
        
        // 4. Mostrar instrucciones inteligentes
        mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario);
        
      } catch (error) {
        console.error('‚ùå Error en navegaci√≥n inteligente:', error);
      }
    }
    // Funci√≥n para procesar el nombre del paradero
    function procesarNombreParadero(nombreCompleto) {
      if (!nombreCompleto) return { nombreParadero: 'Sin nombre', ruta: '' };
      
      const match = nombreCompleto.match(/^([A-Z]\d+[A-Z]?)\s+para\s+(.+)$/i);
      if (match) {
        return {
          nombreParadero: match[2].trim(),
          ruta: match[1].trim()
        };
      }
      
      return {
        nombreParadero: nombreCompleto,
        ruta: ''
      };
    }
    // Geocodificaci√≥n con timeout
    async function geocodificarDireccion(direccion, timeoutMs = 7000) {
      return Promise.race([
        (async () => {
          try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(direccion + ', Cartagena, Colombia')}&limit=1`);
            const data = await response.json();
            if (data.length > 0) {
              return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
            }
            return null;
          } catch (error) {
            console.error('Error geocodificando:', error);
            return null;
          }
        })(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Geocodificaci√≥n muy lenta o sin respuesta')), timeoutMs))
      ]);
    }
    // Leer puntos de partida y destino
    let start = localStorage.getItem('tuguia_start') || '';
    let end = localStorage.getItem('tuguia_end') || '';
    let startMode = localStorage.getItem('tuguia_start_mode') || '';
    let endMode = localStorage.getItem('tuguia_end_mode') || '';
    
    console.log('üìã Datos recibidos del localStorage:', { start, end, startMode, endMode });
    console.log('üü¢ Valor bruto de tuguia_start:', start);
    
    function extraerCoords(str) {
      if (!str) return null;
      try {
        const obj = JSON.parse(str);
        if (obj && Array.isArray(obj.coords)) return obj.coords;
      } catch (e) {}
      let match = str.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
      if (match) return [parseFloat(match[1]), parseFloat(match[2])];
      return null;
    }
    
    let startCoords = extraerCoords(start);
    let endCoords = extraerCoords(end);

    // LOGS DE DEPURACI√ìN
    console.log('üü¢ Coordenadas extra√≠das de tuguia_start:', startCoords);
    console.log('üü¢ Valor bruto de tuguia_end:', end);
    console.log('üü¢ Coordenadas extra√≠das de tuguia_end:', endCoords);
    
    async function procesarInformacion() {
      try {
        console.log('üöÄ Iniciando procesamiento de informaci√≥n...');
        console.log('üìç Start:', start, 'Mode:', startMode, 'Coords:', startCoords);
        console.log('üéØ End:', end, 'Mode:', endMode, 'Coords:', endCoords);

        // Refuerzo: Si ya existen coordenadas, √∫salas directamente y no busques ni geocodifiques
        if (!startCoords || !endCoords) {
          console.error('‚ùå Coordenadas faltantes:', { startCoords, endCoords });
          document.getElementById('info-paraderos').innerHTML = '<b>No se pudo obtener las coordenadas del punto de partida o destino.</b><br>Por favor, selecciona ambos puntos en el mapa o en la lista.';
          document.getElementById('info-ruta').innerHTML = '';
          // Mostrar mensajes de error en los mapas tambi√©n
          document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No hay coordenadas de origen disponibles.';
          document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No hay coordenadas de destino disponibles.';
          return;
        }

        console.log('‚úÖ Coordenadas v√°lidas encontradas:', { startCoords, endCoords });

        // Cargar archivo GeoJSON
        console.log('üìÅ Cargando archivo GeoJSON...');
        const response = await fetch('rutas_transcaribe.geojson');
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        console.log('‚úÖ Archivo GeoJSON cargado, features:', data.features ? data.features.length : 'undefined');
        
        // Guardar en variable global para la navegaci√≥n inteligente
        window.rutasTranscaribe = data.features;
        
        if (!data.features || data.features.length === 0) {
          throw new Error('El archivo GeoJSON no contiene features v√°lidas');
        }

        // Filtrar solo paraderos oficiales de Transcaribe
        console.log('üîç Filtrando paraderos de Transcaribe...');
        let paraderos = data.features.filter(f => {
          // Validaciones b√°sicas
          if (!f || !f.geometry || !f.properties) return false;
          if (f.geometry.type !== 'Point') return false;
          
          const props = f.properties;
          const nombre = (props.name || '').toLowerCase();
          
          // PRIORIDAD 1: Filtrar por network: "Transcaribe" (m√°s espec√≠fico)
          if (props.network && props.network.toLowerCase().includes('transcaribe')) {
            console.log(`‚úÖ Paradero Transcaribe encontrado: ${props.name} (network: ${props.network})`);
            return true;
          }
          
          // PRIORIDAD 2: Filtrar por operator: "Transcaribe"
          if (props.operator && props.operator.toLowerCase().includes('transcaribe')) {
            console.log(`‚úÖ Paradero Transcaribe encontrado: ${props.name} (operator: ${props.operator})`);
            return true;
          }
          
          // PRIORIDAD 3: Filtrar por highway: "bus_stop" Y public_transport: "platform"
          if (props.highway === 'bus_stop' && props.public_transport === 'platform') {
            console.log(`‚úÖ Paradero de bus encontrado: ${props.name} (highway: ${props.highway}, public_transport: ${props.public_transport})`);
            return true;
          }
          
          // Excluir elementos que claramente no son de Transcaribe
          const exclusiones = [
            'citysightseeing', 'tur√≠stico', 'turista', 'tourist', 'moto-taxi', 
            'mototaxi', 'taxi', 'uber', 'didi', 'cabify', 'pasacaballos bus',
            'bus para pasacaballos', 'colectivo', 'buseta', 'chiva'
          ];
          if (exclusiones.some(excl => nombre.includes(excl))) {
            console.log(`‚ùå Paradero excluido: ${props.name} (contiene palabra excluida)`);
            return false;
          }
          
          return false; // Por defecto, no incluir si no cumple criterios espec√≠ficos
        }).map(f => {
          try {
            return {
              id: f.properties['@id'] || f.id || null,
              nombre: f.properties && f.properties.name ? f.properties.name : 'Sin nombre',
              lat: f.geometry.coordinates[1],
              lon: f.geometry.coordinates[0],
              rutas: Array.isArray(f.properties && f.properties.rutas)
                ? f.properties.rutas
                : (typeof f.properties.rutas === 'string' && f.properties.rutas.length > 0
                    ? f.properties.rutas.split(',').map(r => r.trim())
                    : [])
            };
          } catch (error) {
            return null;
          }
        }).filter(f => f !== null);

        console.log('‚úÖ Paraderos filtrados encontrados:', paraderos.length);
        if (paraderos.length === 0) {
          console.warn('‚ö†Ô∏è No se encontraron paraderos v√°lidos en el archivo GeoJSON');
        }

        // Buscar paraderos cercanos al origen con l√≥gica avanzada
        console.log('üìç Buscando paraderos cercanos al origen...');
        // 1. (Opcional) Filtrar por v√≠a y sentido si la informaci√≥n est√° disponible en el GeoJSON
        // Por ejemplo: f.via === viaOrigen && f.sentido === sentidoOrigen
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaOrigen = ...; // Determina la v√≠a del origen
        // let sentidoOrigen = ...; // Determina el sentido del origen
        // paraderos = paraderos.filter(f => f.via === viaOrigen && f.sentido === sentidoOrigen);

        // 2. Calcular distancia a cada paradero
        let paraderosOrigen = paraderos.map(f => {
          let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 m√°s cercanos dentro del radio

        console.log('üìç Paraderos cercanos al origen encontrados:', paraderosOrigen.length);

        // Si no hay paraderos v√°lidos, mostrar los 3 m√°s cercanos aunque est√©n fuera del radio
        if (paraderosOrigen.length === 0) {
          paraderosOrigen = paraderos
            .map(f => {
              let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let html = '';
        let chipOrigen = '';
        if (start && startMode === 'paradero') {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">üìç Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (start) {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">üìç ${obj.nombre}</span>`;
          } catch(e) {}
        }
        if (paraderosOrigen.length === 0) {
          html = '<b>No hay paraderos de Transcaribe cercanos a tu punto de partida.</b><br>Puedes considerar usar otro medio de transporte.';
        } else {
          html = '<b>Paraderos cercanos a tu punto de partida:</b>' + (chipOrigen ? `<div>${chipOrigen}</div>` : '') + '<ul>' + paraderosOrigen.map((p, idx) => {
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            return `<li style="${liStyle}"><b>${p.nombre}</b> (${p.dist.toFixed(0)} m) <br>Rutas: ${(Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas')}</li>`;
          }).join('') + '</ul>';
        }
        document.getElementById('info-paraderos').innerHTML = html;

        // Buscar paraderos cercanos al destino con l√≥gica avanzada
        console.log('üéØ Buscando paraderos cercanos al destino...');
        // 1. (Opcional) Filtrar por v√≠a y sentido si la informaci√≥n est√° disponible en el GeoJSON
        // Por ejemplo: f.via === viaDestino && f.sentido === sentidoDestino
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaDestino = ...; // Determina la v√≠a del destino
        // let sentidoDestino = ...; // Determina el sentido del destino
        // paraderos = paraderos.filter(f => f.via === viaDestino && f.sentido === sentidoDestino);

        // 2. Calcular distancia a cada paradero
        let paraderosDestino = paraderos.map(f => {
          let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 m√°s cercanos dentro del radio

        console.log('üéØ Paraderos cercanos al destino encontrados:', paraderosDestino.length);

        // Si no hay paraderos v√°lidos, mostrar los 3 m√°s cercanos aunque est√©n fuera del radio
        if (paraderosDestino.length === 0) {
          paraderosDestino = paraderos
            .map(f => {
              let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let chipDestino = '';
        if (end && endMode === 'paradero') {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">üéØ Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (end) {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">üéØ ${obj.nombre}</span>`;
          } catch(e) {}
        }
        let paraderosHtml = '<b><span style="color:#006400">Paraderos m√°s cercanos a tu destino:</span></b>' + (chipDestino ? `<div>${chipDestino}</div>` : '') + '<ul id="lista-paraderos-destino"></ul>';
        document.getElementById('info-ruta').innerHTML = paraderosHtml;
        if (paraderosDestino.length === 0) {
          document.getElementById('lista-paraderos-destino').innerHTML = '<li>No hay paraderos de Transcaribe cercanos a tu destino. Prueba ampliando el radio de b√∫squeda o selecciona otro destino.</li>';
        } else {
          let listaHtml = '';
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            listaHtml += `<li id="${liId}" style="${liStyle}">${nombreParadero} (${Math.round(p.dist)} m (l√≠nea recta))<br>Rutas: ${rutasTxt}</li>`;
          });
          document.getElementById('lista-paraderos-destino').innerHTML = listaHtml;
          // Ahora actualizar la distancia caminando de forma as√≠ncrona
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            obtenerDistanciaCaminando(endCoords, [p.lat, p.lon]).then(distanciaCaminando => {
              if (distanciaCaminando && !isNaN(distanciaCaminando)) {
                document.getElementById(liId).innerHTML = `${nombreParadero} (${Math.round(distanciaCaminando)} m (a pie))<br>Rutas: ${rutasTxt}`;
              }
            });
          });
        }

        // Funci√≥n para crear mapas de paraderos cercanos
        async function crearMapasParaderos(paraderosOrigen, paraderosDestino) {
          try {
            console.log('üó∫Ô∏è Creando mapa de origen con', paraderosOrigen ? paraderosOrigen.length : 0, 'paraderos');
            // Crear mapa para paraderos de origen
            if (paraderosOrigen && paraderosOrigen.length > 0) {
              const mapaOrigen = L.map('mapa-origen').setView(startCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
              }).addTo(mapaOrigen);
              
              // Agregar marcador del punto de partida
              L.marker(startCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: 'üìç',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaOrigen).bindPopup('<b>Tu punto de partida</b>');
              
              // Colores para las l√≠neas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosOrigen.slice(0, 3).forEach((paradero, index) => {
                // Marcador del paradero
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: 'üöå',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaOrigen).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el punto de partida al paradero
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando(startCoords, [paradero.lat, paradero.lon], mapaOrigen, color, weight, opacity, 'origen');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([startCoords, ...paraderosOrigen.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaOrigen.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aqu√≠, ya est√° en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de origen
              console.warn('‚ö†Ô∏è No hay paraderos de origen para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No se encontraron paraderos cercanos al punto de partida.';
            }
            
            console.log('üó∫Ô∏è Creando mapa de destino con', paraderosDestino ? paraderosDestino.length : 0, 'paraderos');
            // Crear mapa para paraderos de destino
            if (paraderosDestino && paraderosDestino.length > 0) {
              const mapaDestino = L.map('mapa-destino').setView(endCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
              }).addTo(mapaDestino);
              
              // Agregar marcador del punto de destino
              L.marker(endCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: 'üéØ',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaDestino).bindPopup('<b>Tu punto de destino</b>');
              
              // Colores para las l√≠neas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosDestino.slice(0, 3).forEach((paradero, index) => {
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: 'üöå',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaDestino).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el paradero al punto de destino
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando([paradero.lat, paradero.lon], endCoords, mapaDestino, color, weight, opacity, 'destino');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([endCoords, ...paraderosDestino.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaDestino.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aqu√≠, ya est√° en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de destino
              console.warn('‚ö†Ô∏è No hay paraderos de destino para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No se encontraron paraderos cercanos al punto de destino.';
            }
          } catch (error) {
            console.error('Error creando mapas:', error);
            document.getElementById('mensaje-error-mapa-origen').innerHTML = 'Error al cargar el mapa de origen: ' + error.message;
            document.getElementById('mensaje-error-mapa-destino').innerHTML = 'Error al cargar el mapa de destino: ' + error.message;
          }
        }
        
        // Funci√≥n para insertar leyenda en el mapa
        function insertarLeyendaMapa(containerId) {
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const leyenda = document.createElement('div');
          leyenda.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 1000;
            max-width: 150px;
          `;
          leyenda.innerHTML = `
            <div style="margin-bottom: 5px;"><strong>Leyenda:</strong></div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">üìç</span>
              <span>Tu ubicaci√≥n</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">üéØ</span>
              <span>Tu destino</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">üöå</span>
              <span>Paradero</span>
            </div>
            <div style="display: flex; align-items: center;">
              <div style="width: 20px; height: 3px; background: #1ca12d; margin-right: 5px;"></div>
              <span>Ruta caminando</span>
            </div>
          `;
          container.appendChild(leyenda);
        }
        
        // Funci√≥n para obtener y mostrar rutas caminando
        async function obtenerRutaCaminando(origen, destino, mapa, color, weight = 3, opacity = 0.8, tipo = 'origen') {
          // Forzar color morado oscuro si el color es azul
          if (color === '#007bff' || color === 'blue') color = '#6b46c1';
          const polyline = L.polyline([origen, destino], {
            color: color,
            weight: weight,
            opacity: opacity,
            dashArray: ''
          }).addTo(mapa);
          // Flecha grande a lo largo de toda la l√≠nea
          if (window.L && window.L.polylineDecorator) {
            L.polylineDecorator(polyline, {
              patterns: [
                {
                  offset: '0%',
                  repeat: 0,
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 48,
                    polygon: false,
                    pathOptions: {stroke: true, color: color, weight: weight + 2, opacity: 1}
                  })
                }
              ]
            }).addTo(mapa);
          }
        }
        
        // Crear mapas de paraderos cercanos
        console.log('üó∫Ô∏è Iniciando creaci√≥n de mapas...');
        await crearMapasParaderos(paraderosOrigen, paraderosDestino);
        console.log('‚úÖ Mapas creados exitosamente');
        
        // Forzar redibujado de mapas despu√©s de un breve delay
        setTimeout(() => {
          const mapaOrigen = document.getElementById('mapa-origen');
          const mapaDestino = document.getElementById('mapa-destino');
          if (mapaOrigen && mapaOrigen._leaflet_map) {
            mapaOrigen._leaflet_map.invalidateSize();
          }
          if (mapaDestino && mapaDestino._leaflet_map) {
            mapaDestino._leaflet_map.invalidateSize();
          }
        }, 500);
        
        // =================== ACTIVAR NAVEGACI√ìN INTELIGENTE ===================
        console.log('üß† Activando navegaci√≥n inteligente autom√°ticamente...');
        
        // Verificar si tenemos coordenadas de destino v√°lidas
        if (endCoords && Array.isArray(endCoords) && endCoords.length === 2) {
          console.log('‚úÖ Coordenadas de destino v√°lidas, iniciando navegaci√≥n inteligente...');
          
          // Iniciar navegaci√≥n inteligente autom√°ticamente
          iniciarNavegacionInteligente(endCoords);
        } else {
          console.log('‚ùå No hay coordenadas de destino v√°lidas para navegaci√≥n inteligente');
          document.getElementById('info-ruta').innerHTML = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 1rem; color: #856404;"><strong>‚ö†Ô∏è Navegaci√≥n Inteligente:</strong> No se pudo obtener las coordenadas de destino. Por favor, selecciona un destino v√°lido.</div>';
        }
        
      } catch (error) {
        document.getElementById('info-paraderos').innerHTML = '<b>Error procesando la informaci√≥n:</b> ' + error.message;
      }
    }
    procesarInformacion();
    </script>
    <script>
    // Funci√≥n para obtener la distancia caminando usando OpenRouteService
    async function obtenerDistanciaCaminando(origen, destino) {
      const apiKey = '5b3ce3597851110001cf6248e92a24fdb4744773ab33cab2c808de44';
      const url = `https://api.openrouteservice.org/v2/directions/foot-walking?api_key=${apiKey}`;
      // Log de depuraci√≥n
      console.log('[DISTANCIA CAMINANDO] Enviando a ORS:', {
        origen, destino,
        origenLonLat: [origen[1], origen[0]],
        destinoLonLat: [destino[1], destino[0]]
      });
      const body = {
        coordinates: [
          [origen[1], origen[0]], // [lon, lat]
          [destino[1], destino[0]]
        ]
      };
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const data = await response.json();
        console.log('[DISTANCIA CAMINANDO] Respuesta ORS:', data);
        if (data && data.features && data.features[0]) {
          const distancia = data.features[0].properties.summary.distance;
          if (typeof distancia === 'number' && distancia > 0) {
            return distancia;
          }
        }
        // Si la API responde mal, usar fallback
        console.warn('[DISTANCIA CAMINANDO] ORS no devolvi√≥ distancia v√°lida, usando haversine.');
        return haversine(origen[0], origen[1], destino[0], destino[1]);
      } catch (e) {
        console.error('Error consultando ORS:', e);
        // Fallback a haversine si hay error
        return haversine(origen[0], origen[1], destino[0], destino[1]);
      }
    }
    </script>
    <script>
    let paraderosAuto = [];
    fetch('paraderos.json')
      .then(res => res.json())
      .then(data => {
        paraderosAuto = data;
        inicializarAutocompletado('input-partida', 'sugerencias-partida', 'tuguia_start');
        inicializarAutocompletado('input-destino', 'sugerencias-destino', 'tuguia_end');
      });

    function inicializarAutocompletado(inputId, sugerenciasId, storageKey) {
      const input = document.getElementById(inputId);
      const sugerencias = document.getElementById(sugerenciasId);
      if (!input || !sugerencias) return;
      input.addEventListener('input', function() {
        const texto = input.value.toLowerCase();
        sugerencias.innerHTML = '';
        if (texto.length < 2) return;
        const resultados = paraderosAuto.filter(p => p.nombre.toLowerCase().includes(texto));
        resultados.forEach(p => {
          const div = document.createElement('div');
          div.textContent = p.nombre + ' - ' + p.direccion;
          div.style.cursor = 'pointer';
          div.style.padding = '0.3em 0.5em';
          div.onmouseover = () => div.style.background = '#f0f0ff';
          div.onmouseout = () => div.style.background = '#fff';
          div.onclick = () => {
            input.value = p.nombre;
            sugerencias.innerHTML = '';
            localStorage.setItem(storageKey, JSON.stringify({ nombre: p.nombre, coords: p.coords }));
          };
          sugerencias.appendChild(div);
        });
      });
      input.addEventListener('blur', () => setTimeout(() => sugerencias.innerHTML = '', 200));
    }
    </script>
</div>
<footer class="footer-agapai">
  Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
</footer>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const volverBtn = document.getElementById('volverAGuiaBtn');
  if (volverBtn) {
    volverBtn.addEventListener('click', function() {
      // Limpieza autom√°tica de datos de ruta antes de volver
      localStorage.removeItem('tuguia_start');
      localStorage.removeItem('tuguia_end');
      localStorage.removeItem('tuguia_start_mode');
      localStorage.removeItem('tuguia_end_mode');
      window.location.href = 'index.html';
    });
  }
});
</script>
<script>
// Limpieza autom√°tica de datos de ruta si el usuario navega hacia atr√°s (flecha del navegador)
window.addEventListener('pagehide', function(e) {
  // Si la navegaci√≥n es hacia index.html (o cualquier salida de yotellevo.html)
  // Limpiar solo si la p√°gina se est√° ocultando porque el usuario navega (persisted = false)
  if (!e.persisted) {
    localStorage.removeItem('tuguia_start');
    localStorage.removeItem('tuguia_end');
    localStorage.removeItem('tuguia_start_mode');
    localStorage.removeItem('tuguia_end_mode');
  }
});
</script>
<script>
// Funci√≥n para mostrar la alerta de proximidad (modal + notificaci√≥n + vibraci√≥n)
let alarmaProximidadInterval = null;
function mostrarAlertaProximidad() {
  // Mostrar modal llamativo
  var modal = document.getElementById('modal-proximidad');
  if (modal) modal.style.display = 'flex';

  // Iniciar alarma y vibraci√≥n repetitiva (patr√≥n muy molesto)
  detenerAlarmaProximidad(); // Por si acaso ya hay una activa
  alarmaProximidadInterval = setInterval(() => {
    // Vibraci√≥n muy notoria: vibrar 1200ms, pausa 200ms, repetir varias veces
    if (navigator.vibrate) navigator.vibrate([1200, 200, 1200, 200, 1200, 200, 1200]);
    // Sonido
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 880;
      o.connect(g); g.connect(ctx.destination);
      g.gain.value = 0.2;
      o.start();
      setTimeout(()=>{g.gain.value=0; o.stop(); ctx.close();}, 500);
    } catch(e) {}
  }, 2200);

  // Bot√≥n para detener alarma y vibraci√≥n
  setTimeout(() => {
    const btn = document.getElementById('btnAlertaEntendido');
    if (btn) {
      btn.onclick = function() {
        detenerAlarmaProximidad();
        modal.style.display = 'none';
      };
    }
  }, 100);

  // Notificaci√≥n del sistema (opcional, no bloquea la alarma/vibraci√≥n)
  if (window.Notification && Notification.permission === 'granted') {
    new Notification('¬°Faltan menos de 300 metros!', {
      body: 'Prep√°rate para descender en tu destino.',
      icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
    });
  } else if (window.Notification && Notification.permission !== 'denied') {
    Notification.requestPermission().then(function(permission) {
      if (permission === 'granted') {
        new Notification('¬°Faltan menos de 300 metros!', {
          body: 'Prep√°rate para descender en tu destino.',
          icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
        });
      }
    });
  }
}

function detenerAlarmaProximidad() {
  if (alarmaProximidadInterval) {
    clearInterval(alarmaProximidadInterval);
    alarmaProximidadInterval = null;
  }
  if (navigator.vibrate) navigator.vibrate(0); // Detener vibraci√≥n
}
    </script>
    <script>
    // Script adicional para asegurar que los mapas se carguen correctamente
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que los contenedores de mapas existan
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen) {
        console.log('‚úÖ Contenedor mapa-origen encontrado');
      } else {
        console.error('‚ùå Contenedor mapa-origen no encontrado');
      }
      
      if (mapaDestino) {
        console.log('‚úÖ Contenedor mapa-destino encontrado');
      } else {
        console.error('‚ùå Contenedor mapa-destino no encontrado');
      }
      
      // Verificar que Leaflet est√© disponible
      if (typeof L !== 'undefined') {
        console.log('‚úÖ Leaflet cargado correctamente');
      } else {
        console.error('‚ùå Leaflet no est√° disponible');
      }
    });
    
    // Funci√≥n para forzar el redibujado de mapas
    function redibujarMapas() {
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen && mapaOrigen._leaflet_map) {
        mapaOrigen._leaflet_map.invalidateSize();
        console.log('üîÑ Mapa de origen redibujado');
      }
      
      if (mapaDestino && mapaDestino._leaflet_map) {
        mapaDestino._leaflet_map.invalidateSize();
        console.log('üîÑ Mapa de destino redibujado');
      }
    }
    
    // Redibujar mapas cuando la ventana cambie de tama√±o
    window.addEventListener('resize', redibujarMapas);
    
    // Redibujar mapas despu√©s de que la p√°gina se cargue completamente
    window.addEventListener('load', function() {
      setTimeout(redibujarMapas, 1000);
    });
    </script>
    <script>
    // --- FUNCIONES UTILITARIAS GLOBALES ---
    function limpiarDireccionParaMostrar(displayName) {
      if (!displayName) return '';
      const partes = displayName.split(',').map(s => s.trim());
      const irrelevantes = [
        'Cartagena de Indias',
        'Cartagena',
        'Bolivar',
        'Bol√≠var',
        '130003',
        'Dique',
        'Tierra Bomba',
        '130018',
        '130010',
        '130001',
        'Colombia'
      ];
      let partesFiltradas = partes.filter(parte => {
        const p = parte.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        return !irrelevantes.includes(parte) && !irrelevantes.includes(p);
      });
      // Elimina duplicados consecutivos
      partesFiltradas = partesFiltradas.filter((parte, idx, arr) => idx === 0 || parte !== arr[idx-1]);
      return partesFiltradas.join(', ');
    }
    // ... el resto del c√≥digo JS ...
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üü£ [INIT] DOMContentLoaded en yotellevo.html');
      let start = localStorage.getItem('tuguia_start') || '';
      let end = localStorage.getItem('tuguia_end') || '';
      let startMode = localStorage.getItem('tuguia_start_mode') || '';
      let endMode = localStorage.getItem('tuguia_end_mode') || '';
      console.log('üü£ [INIT] Datos localStorage:', { start, end, startMode, endMode });

      function extraerCoords(str) {
        if (!str) return null;
        try {
          const obj = JSON.parse(str);
          if (obj && Array.isArray(obj.coords)) return obj.coords;
        } catch (e) {}
        let match = str.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
        if (match) return [parseFloat(match[1]), parseFloat(match[2])];
        return null;
      }

      let startCoords = extraerCoords(start);
      let endCoords = extraerCoords(end);
      console.log('üü£ [INIT] Coordenadas extra√≠das:', { startCoords, endCoords });

      if (!startCoords || !endCoords) {
        console.warn('üü£ [INIT] Faltan coordenadas de inicio o fin. No se puede mostrar el panel.');
        return;
      }

      try {
        // Simula el flujo de navegaci√≥n inteligente
        console.log('üü£ [INIT] Llamando a iniciarNavegacionInteligente con:', endCoords);
        await iniciarNavegacionInteligente(endCoords);
        console.log('üü£ [INIT] Panel Tu Gu√≠a Inteligente deber√≠a mostrarse si todo fue bien.');
      } catch (error) {
        console.error('üü£ [INIT] Error al intentar mostrar el panel:', error);
      }
    });
    </script>
</body>
</html> 