<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â¡Yo te llevo! - Tuguia</title>
    <style>
        body {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            padding: 2rem 0;
        }
        
        .main-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            gap: 1rem;
        }
        
        .container {
            background: white;
            border-radius: 22px;
            box-shadow: 0 8px 32px rgba(107,70,193,0.10);
            padding: 2.5rem 2rem 2rem 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        .title {
            font-size: 2rem;
            color: #6b46c1;
            font-weight: 700;
            margin-bottom: 1.2rem;
            letter-spacing: 0.5px;
        }
        .subtitle {
            font-size: 1.1rem;
            color: #4a5568;
            margin-bottom: 2.2rem;
            font-weight: 400;
        }
        .big-icon {
            font-size: 3.5rem;
            margin-bottom: 1.2rem;
            color: #ff6600;
        }
        .main-btn {
            background: linear-gradient(135deg, #6b46c1, #553c9a);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.9rem 2.2rem;
            box-shadow: 0 6px 20px rgba(107,70,193,0.13);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            letter-spacing: 0.5px;
            margin-top: 1.5rem;
        }
        .main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 32px rgba(107,70,193,0.18);
        }
        .info-section {
            margin-top: 1.5rem;
            text-align: left;
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .info-section ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .info-section li {
            margin-bottom: 0.5rem;
        }
        .footer-agapai {
            width: 100vw;
            text-align: center;
            padding: 1.2em 0 0.7em 0;
            font-size: 10px;
            color: #6b46c1;
            font-weight: 400;
            letter-spacing: 0.5px;
            position: fixed;
            left: 0;
            bottom: 0;
            background: transparent;
            z-index: 100;
        }
        .footer-agapai a {
            color: #ff6600;
            text-decoration: none;
            font-weight: 400;
        }
        @media (max-width: 600px) {
            .footer-agapai { font-size: 0.95em; padding-bottom: 0.5em; }
        }
        
        /* Estilos para los contenedores de mapas */
        .map-container {
            background: white;
            border-radius: 18px;
            box-shadow: 0 6px 24px rgba(107,70,193,0.08);
            padding: 1.8rem;
            margin: 1rem auto;
            max-width: 600px;
            width: 90%;
        }
        
        .map-title {
            font-size: 1.3rem;
            color: #6b46c1;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
            letter-spacing: 0.3px;
        }
        
        .map-subtitle {
            font-size: 0.9rem;
            color: #718096;
            font-weight: 400;
            margin-bottom: 1.2rem;
            text-align: center;
            font-style: italic;
        }
        
        .map-area {
            height: 400px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            border: 1px solid #e2e8f0;
        }
        @media (max-width: 768px) {
            .map-area {
                height: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="container">
            <div class="big-icon">ğŸ§­</div>
            <div class="title" style="display:flex;align-items:center;gap:12px;justify-content:center;">
              <div style="display:flex;align-items:center;gap:12px;background:#f3f0ff;border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.10);padding:16px 32px;border:4px solid #d1c4e9;">
                <img src="logoagapai-ok2.png" alt="Logo Agapai" style="height:56px;width:auto;vertical-align:middle;display:inline-block;" />
                <span style="font-family:'Segoe UI',Arial,sans-serif;font-size:2rem;color:#6b46c1;font-weight:700;letter-spacing:0.5px;">Â¡Yo te llevo!</span>
              </div>
            </div>
            <div class="subtitle">Â¿No sabes cÃ³mo llegar a tu destino?<br>DÃ©jalo en mis manos, te ayudo a encontrar la mejor ruta y te acompaÃ±o en el camino.</div>
            <div id="info-paraderos" class="info-section"></div>
            <div id="info-ruta" class="info-section"></div>
            <!-- Reemplaza el enlace por un botÃ³n funcional para volver a la guÃ­a -->
            <button id="volverAGuiaBtn" class="main-btn">Volver a Tu GuÃ­a</button>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DE PARTIDA -->
        <div class="map-container">
            <h3 class="map-title">ğŸ—ºï¸ Paraderos cercanos a tu Punto de Partida</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>ğŸ“ Tu ubicaciÃ³n</span>
              <span>ğŸ¯ Tu destino</span>
              <span>ğŸšŒ Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-origen" class="map-area"></div>
            <div id="mensaje-error-mapa-origen" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DESTINO -->
        <div class="map-container">
            <h3 class="map-title">ğŸ¯ Paraderos cercanos a tu Punto Destino</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>ğŸ“ Tu ubicaciÃ³n</span>
              <span>ğŸ¯ Tu destino</span>
              <span>ğŸšŒ Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-destino" class="map-area"></div>
            <div id="mensaje-error-mapa-destino" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
    </div>
    
    <!-- Modal de alerta de proximidad -->
    <div id="modal-proximidad" style="display:none;position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);justify-content:center;align-items:center;">
      <div style="background:#fffbe6;border:4px solid #ff9800;border-radius:18px;padding:2em 2em 1.5em 2em;box-shadow:0 8px 32px #0008;text-align:center;max-width:90vw;">
        <div style="font-size:2.2em;color:#ff9800;font-weight:bold;margin-bottom:0.5em;">Â¡AtenciÃ³n!</div>
        <div style="font-size:1.3em;color:#333;margin-bottom:1em;">Faltan menos de <b>300 metros</b> para llegar a tu destino.<br>PrepÃ¡rate para descender.</div>
        <button onclick="document.getElementById('modal-proximidad').style.display='none'" style="font-size:1.1em;padding:0.5em 1.5em;background:#ff9800;color:#fff;border:none;border-radius:8px;cursor:pointer;">Entendido</button>
      </div>
    </div>
    <footer class="footer-agapai">
        Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
    </footer>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline"></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
    <script>
    // =================== LÃ“GICA DE NAVEGACIÃ“N INTELIGENTE ===================
    
    // Variables globales para el seguimiento inteligente
    let isIntelligentTrackingActive = false;
    let intelligentTrackingWatchId = null;
    let intelligentTrackingStartTime = null;
    let intelligentTrackingLastPosition = null;
    let intelligentTrackingDistance = 0;
    let intelligentTrackingAlarmaActivada = false;
    let intelligentTrackingDestino = null;
    let rutaOptimaCalculada = null;
    let paraderoCercanoEncontrado = null;
    
    // Utilidad para calcular distancia entre dos puntos (Haversine)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Radio de la Tierra en metros
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // FunciÃ³n para obtener ubicaciÃ³n GPS
    function obtenerUbicacionGPS() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('GeolocalizaciÃ³n no soportada'));
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            resolve({
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              accuracy: pos.coords.accuracy
            });
          },
          (error) => {
            reject(new Error(`Error de geolocalizaciÃ³n: ${error.message}`));
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      });
    }
    
    // FunciÃ³n para geocodificaciÃ³n inversa (coordenadas a direcciÃ³n)
    async function obtenerDireccionDesdeCoordenadas(lat, lng) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
        const data = await response.json();
        if (data && data.address) {
          return data; // Devolver el objeto completo
        }
        return null;
      } catch (error) {
        console.error('âŒ Error en geocodificaciÃ³n inversa:', error);
        return null;
      }
    }
    
    // FunciÃ³n para encontrar paradero mÃ¡s cercano
    async function encontrarParaderoMasCercano(ubicacionUsuario) {
      if (!window.rutasTranscaribe || !Array.isArray(window.rutasTranscaribe)) {
        console.error('âŒ No hay datos de paraderos disponibles');
        return null;
      }
      
      console.log('ğŸ” === BUSCANDO PARADERO MÃS CERCANO ===');
      console.log('ğŸ“ UbicaciÃ³n usuario:', ubicacionUsuario);
      console.log('ğŸ“Š Total de features en GeoJSON:', window.rutasTranscaribe.length);
      
      let paraderoMasCercano = null;
      let distanciaMinima = Infinity;
      
      // Filtrar solo paraderos Transcaribe
      const paraderosTranscaribe = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      console.log('ğŸšŒ Paraderos Transcaribe encontrados:', paraderosTranscaribe.length);
      
      paraderosTranscaribe.forEach((paradero, index) => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const distancia = haversine(
          ubicacionUsuario.lat, ubicacionUsuario.lng,
          lat, lon
        );
        
        // Log del primer paradero para debugging
        if (index === 0) {
          console.log('ğŸ” Ejemplo de paradero:', {
            nombre: paradero.properties.nombre_paradero,
            rutas: paradero.properties.rutas,
            network: paradero.properties.network,
            distancia: distancia
          });
        }
        
        if (distancia < distanciaMinima) {
          distanciaMinima = distancia;
          paraderoMasCercano = {
            nombre: paradero.properties.nombre_paradero || 'Paradero',
            lat: lat,
            lon: lon,
            distancia: distancia,
            rutas: paradero.properties.rutas || '',
            tipos_ruta: paradero.properties.tipos_ruta || ''
          };
        }
      });
      
      console.log('ğŸ“ Paradero mÃ¡s cercano encontrado:', paraderoMasCercano);
      return paraderoMasCercano;
    }
    
    // FunciÃ³n para verificar ruta directa
    function verificarRutaDirecta(paraderoOrigen, paraderoDestino) {
      console.log('ğŸ” === VERIFICANDO RUTA DIRECTA ===');
      console.log('ğŸ“ Paradero Origen:', paraderoOrigen);
      console.log('ğŸ¯ Paradero Destino:', paraderoDestino);
      // Convertir rutas de string a array si es necesario
      const rutasOrigen = typeof paraderoOrigen.rutas === 'string' ? 
        paraderoOrigen.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoOrigen.rutas) ? paraderoOrigen.rutas : []);
      const rutasDestino = typeof paraderoDestino.rutas === 'string' ? 
        paraderoDestino.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoDestino.rutas) ? paraderoDestino.rutas : []);
      console.log('ğŸšŒ Rutas Origen (procesadas):', rutasOrigen);
      console.log('ğŸšŒ Rutas Destino (procesadas):', rutasDestino);
      // Buscar intersecciÃ³n
      const rutasComunes = rutasOrigen.filter(ruta => rutasDestino.includes(ruta));
      console.log('ğŸŸ¢ Rutas comunes (intersecciÃ³n):', rutasComunes);
      if (rutasComunes.length > 0) {
        console.log('âœ… Ruta directa encontrada:', rutasComunes[0]);
        return { ruta: rutasComunes[0], todas: rutasComunes };
      }
      console.log('âŒ No se encontrÃ³ ruta directa');
      return null;
    }
    
    // FunciÃ³n para encontrar mejor transbordo
    function encontrarMejorTransbordo(paraderoOrigen, paraderoDestino) {
      if (!window.rutasTranscaribe) return null;
      
      // Buscar paraderos que conecten las rutas
      const paraderosTransbordo = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      let mejorTransbordo = null;
      let mejorScore = Infinity;
      
      paraderosTransbordo.forEach(paradero => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const rutasParadero = typeof paradero.properties.rutas === 'string' ? 
          paradero.properties.rutas.split(',').map(r => r.trim()) : 
          (Array.isArray(paradero.properties.rutas) ? paradero.properties.rutas : []);
        
        // Verificar si este paradero conecta origen y destino
        const rutaDesdeOrigen = verificarRutaDirecta(paraderoOrigen, {
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        });
        
        const rutaHastaDestino = verificarRutaDirecta({
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        }, paraderoDestino);
        
        if (rutaDesdeOrigen && rutaHastaDestino) {
          // Calcular score basado en distancia total
          const distOrigenTransbordo = haversine(
            paraderoOrigen.lat, paraderoOrigen.lon,
            lat, lon
          );
          
          const distTransbordoDestino = haversine(
            lat, lon,
            paraderoDestino.lat, paraderoDestino.lon
          );
          
          const score = distOrigenTransbordo + distTransbordoDestino;
          
          if (score < mejorScore) {
            mejorScore = score;
            mejorTransbordo = {
              paraderoTransbordo: {
                nombre: paradero.properties.nombre_paradero,
                lat: lat,
                lon: lon
              },
              ruta1: rutaDesdeOrigen.ruta,
              ruta2: rutaHastaDestino.ruta,
              score: score
            };
          }
        }
      });
      
      return mejorTransbordo;
    }
    
    // FunciÃ³n para calcular ruta Ã³ptima
    async function calcularRutaOptima(paraderoOrigen, destinoCoords) {
      if (!destinoCoords) {
        console.error('âŒ No hay coordenadas de destino');
        return null;
      }
      // Buscar paradero mÃ¡s cercano al destino
      const paraderoDestino = await encontrarParaderoMasCercano({
        lat: destinoCoords[0],
        lng: destinoCoords[1]
      });
      if (!paraderoDestino) {
        console.error('âŒ No se encontrÃ³ paradero cercano al destino');
        return null;
      }
      // Verificar si hay ruta directa
      const rutaDirecta = verificarRutaDirecta(paraderoOrigen, paraderoDestino);
      console.log('ğŸŸ¢ Resultado de verificarRutaDirecta:', rutaDirecta);
      if (rutaDirecta && rutaDirecta.todas && rutaDirecta.todas.length > 0) {
        let rutasTexto = rutaDirecta.todas.length === 1 ? `la ruta ${rutaDirecta.todas[0]}` : `las rutas ${rutaDirecta.todas.join(', ')}`;
        const mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevarÃ¡ directamente a ${paraderoDestino.nombre}.`;
        return {
          tipo: 'directa',
          paraderoOrigen: paraderoOrigen,
          paraderoDestino: paraderoDestino,
          ruta: rutaDirecta.todas,
          mensaje: mensaje,
          pasos: rutaDirecta.todas.map(ruta => ({ accion: 'tomar', ruta: ruta, desde: paraderoOrigen, hasta: paraderoDestino }))
        };
      } else {
        // Buscar transbordo
        const transbordo = encontrarMejorTransbordo(paraderoOrigen, paraderoDestino);
        if (transbordo && transbordo.ruta1 && transbordo.ruta2) {
          const mensaje = `Toma la ruta ${transbordo.ruta1} hasta ${transbordo.paraderoTransbordo.nombre}. AllÃ­ cambia a la ruta ${transbordo.ruta2} hasta ${paraderoDestino.nombre}.`;
          return {
            tipo: 'con_transbordo',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            paraderoTransbordo: transbordo.paraderoTransbordo,
            ruta1: transbordo.ruta1,
            ruta2: transbordo.ruta2,
            mensaje: mensaje,
            pasos: [
              { accion: 'tomar', ruta: transbordo.ruta1, desde: paraderoOrigen, hasta: transbordo.paraderoTransbordo },
              { accion: 'transbordar', en: transbordo.paraderoTransbordo },
              { accion: 'tomar', ruta: transbordo.ruta2, desde: transbordo.paraderoTransbordo, hasta: paraderoDestino }
            ]
          };
        } else {
          // Si no hay ruta directa ni transbordo vÃ¡lido, mostrar advertencia
          const mensaje = 'No se encontrÃ³ una ruta directa ni con transbordo entre los paraderos seleccionados.';
          return {
            tipo: 'sin_ruta',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            mensaje: mensaje,
            pasos: []
          };
        }
      }
    }
    
    // FunciÃ³n para mostrar instrucciones inteligentes
    function mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario) {
      console.log('ğŸ“‹ === MOSTRANDO INSTRUCCIONES INTELIGENTES ===');
      console.log('ğŸ§  Ruta Ã³ptima:', rutaOptima);
      console.log('ğŸ“ Paradero cercano:', paraderoCercano);
      console.log('ğŸ“ UbicaciÃ³n usuario:', ubicacionUsuario);
      console.log('ğŸ“ Mensaje de ruta:', rutaOptima.mensaje);
      
      // Obtener direcciÃ³n desde coordenadas
      obtenerDireccionDesdeCoordenadas(ubicacionUsuario.lat, ubicacionUsuario.lng).then(direccion => {
        console.log('ğŸŒ DirecciÃ³n obtenida:', direccion);
        
        // Crear panel de instrucciones inteligentes
        let instruccionesHTML = `
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px; margin: 1rem 0; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.3rem;">ğŸ§  Tu GuÃ­a Inteligente</h3>
            <div style="margin-bottom: 1rem;">
              <strong>ğŸ“ Tu ubicaciÃ³n:</strong> ${direccion.display_name}
            </div>
            <div style="margin-bottom: 1rem;">
              <strong>ğŸšŒ Paradero mÃ¡s cercano:</strong> ${paraderoCercano.nombre} (${Math.round(paraderoCercano.distancia)}m)
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px;">
              <strong>ğŸ“‹ Instrucciones:</strong><br>
              ${rutaOptima.mensaje}
            </div>
            <div style="margin-top: 1rem; text-align: center;">
              <button id="iniciarSeguimientoBtn" style="background: #ff6600; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; font-weight: bold; cursor: pointer;">
                ğŸš€ Iniciar Seguimiento Inteligente
              </button>
            </div>
          </div>
        `;
        
        console.log('ğŸ“‹ HTML generado:', instruccionesHTML);
        
        // Insertar instrucciones en el DOM
        const infoElement = document.getElementById('info-ruta');
        if (infoElement) {
          infoElement.innerHTML = instruccionesHTML;
          
          // Agregar event listener al botÃ³n de iniciar seguimiento
          setTimeout(() => {
            const btn = document.getElementById('iniciarSeguimientoBtn');
            if (btn) {
              btn.addEventListener('click', () => {
                iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario);
              });
            }
          }, 100);
        }
        
        console.log('ğŸ“‹ Instrucciones inteligentes mostradas:', rutaOptima.mensaje);
      }).catch(error => {
        console.error('âŒ Error obteniendo direcciÃ³n:', error);
        // Fallback: mostrar coordenadas si falla la geocodificaciÃ³n
        let instruccionesHTML = `
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px; margin: 1rem 0; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 1rem 0; font-size: 1.3rem;">ğŸ§  Tu GuÃ­a Inteligente</h3>
            <div style="margin-bottom: 1rem;">
              <strong>ğŸ“ Tu ubicaciÃ³n:</strong> ${ubicacionUsuario.lat.toFixed(6)}, ${ubicacionUsuario.lng.toFixed(6)}
            </div>
            <div style="margin-bottom: 1rem;">
              <strong>ğŸšŒ Paradero mÃ¡s cercano:</strong> ${paraderoCercano.nombre} (${Math.round(paraderoCercano.distancia)}m)
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px;">
              <strong>ğŸ“‹ Instrucciones:</strong><br>
              ${rutaOptima.mensaje}
            </div>
            <div style="margin-top: 1rem; text-align: center;">
              <button id="iniciarSeguimientoBtn" style="background: #ff6600; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 8px; font-weight: bold; cursor: pointer;">
                ğŸš€ Iniciar Seguimiento Inteligente
              </button>
            </div>
          </div>
        `;
        
        // Insertar instrucciones en el DOM
        const infoElement = document.getElementById('info-ruta');
        if (infoElement) {
          infoElement.innerHTML = instruccionesHTML;
          
          // Agregar event listener al botÃ³n de iniciar seguimiento
          setTimeout(() => {
            const btn = document.getElementById('iniciarSeguimientoBtn');
            if (btn) {
              btn.addEventListener('click', () => {
                iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario);
              });
            }
          }, 100);
        }
        
        console.log('ğŸ“‹ Instrucciones inteligentes mostradas (fallback):', rutaOptima.mensaje);
      });
    }
    
    // FunciÃ³n para iniciar seguimiento inteligente
    function iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario) {
      if (isIntelligentTrackingActive) return;
      
      isIntelligentTrackingActive = true;
      intelligentTrackingDistance = 0;
      intelligentTrackingAlarmaActivada = false;
      intelligentTrackingStartTime = Date.now();
      intelligentTrackingLastPosition = null;
      intelligentTrackingDestino = [rutaOptima.paraderoDestino.lat, rutaOptima.paraderoDestino.lon];
      rutaOptimaCalculada = rutaOptima;
      paraderoCercanoEncontrado = paraderoCercano;
      
      // Crear panel de seguimiento
      const seguimientoHTML = `
        <div style="background: #f8f9fa; border: 2px solid #007bff; border-radius: 12px; padding: 1.5rem; margin: 1rem 0;">
          <h4 style="margin: 0 0 1rem 0; color: #007bff;">ğŸš€ Seguimiento Inteligente Activo</h4>
          <div id="leyenda-barrio" style="font-size:1.1em;color:#6b46c1;font-weight:600;margin-bottom:0.7em;"></div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
            <div>
              <strong>ğŸ“ Distancia recorrida:</strong><br>
              <span id="distanciaRecorrida">0.0 km</span>
            </div>
            <div>
              <strong>â±ï¸ Tiempo transcurrido:</strong><br>
              <span id="tiempoTranscurrido">00:00</span>
            </div>
            <div>
              <strong>ğŸš¶ Velocidad actual:</strong><br>
              <span id="velocidadActual">0.0 km/h</span>
            </div>
            <div>
              <strong>ğŸ“ Estado:</strong><br>
              <span id="estadoSeguimiento">ğŸ“ Iniciando...</span>
            </div>
          </div>
          <div style="background: #e9ecef; border-radius: 8px; padding: 0.5rem; margin-bottom: 1rem;">
            <div style="background: #007bff; height: 8px; border-radius: 4px; width: 0%; transition: width 0.3s;" id="barraProgreso"></div>
          </div>
          <button id="detenerSeguimientoBtn" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer;">
            â¹ï¸ Detener Seguimiento
          </button>
        </div>
      `;
      
      // Reemplazar las instrucciones con el panel de seguimiento
      const infoElement = document.getElementById('info-ruta');
      if (infoElement) {
        infoElement.innerHTML = seguimientoHTML;
        
        // Agregar event listener al botÃ³n de detener
        setTimeout(() => {
          const btn = document.getElementById('detenerSeguimientoBtn');
          if (btn) {
            btn.addEventListener('click', detenerSeguimientoInteligente);
          }
        }, 100);
      }
      
      // Iniciar seguimiento de ubicaciÃ³n
      if (intelligentTrackingWatchId) navigator.geolocation.clearWatch(intelligentTrackingWatchId);
      
      intelligentTrackingWatchId = navigator.geolocation.watchPosition(
        function(pos) {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const current = L.latLng(lat, lon);
          
          // Calcular distancia recorrida
          if (intelligentTrackingLastPosition) {
            const d = intelligentTrackingLastPosition.distanceTo(current);
            if (d > 2) { // Solo sumar si el movimiento es real (>2m)
              intelligentTrackingDistance += d;
            }
          }
          intelligentTrackingLastPosition = current;
          
          // Actualizar UI
          document.getElementById('distanciaRecorrida').textContent = (intelligentTrackingDistance / 1000).toFixed(2) + ' km';
          
          // Actualizar tiempo
          const elapsed = (Date.now() - intelligentTrackingStartTime) / 1000;
          const min = Math.floor(elapsed / 60);
          const sec = Math.floor(elapsed % 60);
          document.getElementById('tiempoTranscurrido').textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
          
          // Calcular velocidad
          const speedKmh = pos.coords.speed && pos.coords.speed > 0 ? (pos.coords.speed * 3.6) : (intelligentTrackingDistance / elapsed) * 3.6;
          document.getElementById('velocidadActual').textContent = speedKmh > 0 ? speedKmh.toFixed(1) + ' km/h' : '0.0 km/h';
          
          // Estado
          const estadoElement = document.getElementById('estadoSeguimiento');
          if (speedKmh > 0.5) {
            estadoElement.textContent = 'ğŸŸ¢ En movimiento';
            estadoElement.style.color = '#28a745';
          } else {
            estadoElement.textContent = 'â¸ï¸ Detenido';
            estadoElement.style.color = '#dc3545';
          }
          
          // Barra de progreso
          if (intelligentTrackingDestino) {
            const distRestante = current.distanceTo(L.latLng(intelligentTrackingDestino[0], intelligentTrackingDestino[1]));
            let totalDist = intelligentTrackingDistance + distRestante;
            let progress = totalDist > 0 ? (intelligentTrackingDistance / totalDist) * 100 : 0;
            document.getElementById('barraProgreso').style.width = progress + '%';
            
            // Alarma a 300m
            if (!intelligentTrackingAlarmaActivada && distRestante <= 300 && distRestante > 30) {
              intelligentTrackingAlarmaActivada = true;
              mostrarAlertaProximidad();
            }
            // === NUEVO: Detener automÃ¡ticamente al llegar al destino ===
            if (distRestante <= 30 && isIntelligentTrackingActive) {
              detenerSeguimientoInteligente();
            }
          }
          
          // Actualizar leyenda de barrio
          obtenerDireccionDesdeCoordenadas(lat, lon).then(data => {
            let barrio = '';
            if (data && data.address) {
              barrio = data.address.suburb || data.address.neighbourhood || data.address.quarter || data.address.city_district || data.address.city || '';
              if (!barrio && data.display_name) {
                barrio = data.display_name.split(',')[0];
              }
            }
            document.getElementById('leyenda-barrio').textContent = barrio ? `Vamos Por: ${barrio}` : '';
          });
        },
        function(error) {
          console.error('Error en seguimiento inteligente:', error);
          document.getElementById('estadoSeguimiento').textContent = 'âŒ Error de GPS';
          document.getElementById('estadoSeguimiento').style.color = '#dc3545';
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        }
      );
      
      console.log('ğŸš€ Seguimiento inteligente iniciado');
    }
    
    // FunciÃ³n para detener seguimiento inteligente
    function detenerSeguimientoInteligente() {
      if (intelligentTrackingWatchId) {
        navigator.geolocation.clearWatch(intelligentTrackingWatchId);
        intelligentTrackingWatchId = null;
      }
      
      isIntelligentTrackingActive = false;
      
      // Mostrar resumen
      const resumenHTML = `
        <div style="background: #d4edda; border: 2px solid #28a745; border-radius: 12px; padding: 1.5rem; margin: 1rem 0;">
          <h4 style="margin: 0 0 1rem 0; color: #155724;">âœ… Recorrido Finalizado</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
              <strong>ğŸ“ Distancia total:</strong><br>
              <span>${(intelligentTrackingDistance / 1000).toFixed(2)} km</span>
            </div>
            <div>
              <strong>â±ï¸ Tiempo total:</strong><br>
              <span>${document.getElementById('tiempoTranscurrido').textContent}</span>
            </div>
          </div>
          <button onclick="window.location.reload()" style="background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; margin-top: 1rem;">
            ğŸ”„ Iniciar Nuevo Seguimiento
          </button>
        </div>
      `;
      
      const infoElement = document.getElementById('info-ruta');
      if (infoElement) {
        infoElement.innerHTML = resumenHTML;
      }
    }
    
    // FunciÃ³n principal de navegaciÃ³n inteligente
    async function iniciarNavegacionInteligente(destinoCoords) {
      try {
        console.log('ğŸ§  Iniciando navegaciÃ³n inteligente...');
        
        // 1. Obtener ubicaciÃ³n GPS actual
        const ubicacionUsuario = await obtenerUbicacionGPS();
        if (!ubicacionUsuario) {
          console.error('âŒ No se pudo obtener ubicaciÃ³n GPS');
          return;
        }
        
        // 2. Encontrar paradero mÃ¡s cercano automÃ¡ticamente
        const paraderoCercano = await encontrarParaderoMasCercano(ubicacionUsuario);
        if (!paraderoCercano) {
          console.error('âŒ No se encontrÃ³ paradero cercano');
          return;
        }
        
        // 3. Calcular ruta Ã³ptima automÃ¡ticamente
        const rutaOptima = await calcularRutaOptima(paraderoCercano, destinoCoords);
        if (!rutaOptima) {
          console.error('âŒ No se pudo calcular ruta Ã³ptima');
          return;
        }
        
        // 4. Mostrar instrucciones inteligentes
        mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario);
        
      } catch (error) {
        console.error('âŒ Error en navegaciÃ³n inteligente:', error);
      }
    }
    // FunciÃ³n para procesar el nombre del paradero
    function procesarNombreParadero(nombreCompleto) {
      if (!nombreCompleto) return { nombreParadero: 'Sin nombre', ruta: '' };
      
      const match = nombreCompleto.match(/^([A-Z]\d+[A-Z]?)\s+para\s+(.+)$/i);
      if (match) {
        return {
          nombreParadero: match[2].trim(),
          ruta: match[1].trim()
        };
      }
      
      return {
        nombreParadero: nombreCompleto,
        ruta: ''
      };
    }
    // GeocodificaciÃ³n con timeout
    async function geocodificarDireccion(direccion, timeoutMs = 7000) {
      return Promise.race([
        (async () => {
          try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(direccion + ', Cartagena, Colombia')}&limit=1`);
            const data = await response.json();
            if (data.length > 0) {
              return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
            }
            return null;
          } catch (error) {
            console.error('Error geocodificando:', error);
            return null;
          }
        })(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('GeocodificaciÃ³n muy lenta o sin respuesta')), timeoutMs))
      ]);
    }
    // Leer puntos de partida y destino
    let start = localStorage.getItem('tuguia_start') || '';
    let end = localStorage.getItem('tuguia_end') || '';
    let startMode = localStorage.getItem('tuguia_start_mode') || '';
    let endMode = localStorage.getItem('tuguia_end_mode') || '';
    
    console.log('ğŸ“‹ Datos recibidos del localStorage:', { start, end, startMode, endMode });
    console.log('ğŸŸ¢ Valor bruto de tuguia_start:', start);
    
    function extraerCoords(str) {
      if (!str) return null;
      try {
        const obj = JSON.parse(str);
        if (obj && Array.isArray(obj.coords)) return obj.coords;
      } catch (e) {}
      let match = str.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
      if (match) return [parseFloat(match[1]), parseFloat(match[2])];
      return null;
    }
    
    let startCoords = extraerCoords(start);
    let endCoords = extraerCoords(end);

    // LOGS DE DEPURACIÃ“N
    console.log('ğŸŸ¢ Coordenadas extraÃ­das de tuguia_start:', startCoords);
    console.log('ğŸŸ¢ Valor bruto de tuguia_end:', end);
    console.log('ğŸŸ¢ Coordenadas extraÃ­das de tuguia_end:', endCoords);
    
    async function procesarInformacion() {
      try {
        console.log('ğŸš€ Iniciando procesamiento de informaciÃ³n...');
        console.log('ğŸ“ Start:', start, 'Mode:', startMode, 'Coords:', startCoords);
        console.log('ğŸ¯ End:', end, 'Mode:', endMode, 'Coords:', endCoords);

        // Refuerzo: Si ya existen coordenadas, Ãºsalas directamente y no busques ni geocodifiques
        if (!startCoords || !endCoords) {
          console.error('âŒ Coordenadas faltantes:', { startCoords, endCoords });
          document.getElementById('info-paraderos').innerHTML = '<b>No se pudo obtener las coordenadas del punto de partida o destino.</b><br>Por favor, selecciona ambos puntos en el mapa o en la lista.';
          document.getElementById('info-ruta').innerHTML = '';
          // Mostrar mensajes de error en los mapas tambiÃ©n
          document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No hay coordenadas de origen disponibles.';
          document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No hay coordenadas de destino disponibles.';
          return;
        }

        console.log('âœ… Coordenadas vÃ¡lidas encontradas:', { startCoords, endCoords });

        // Cargar archivo GeoJSON
        console.log('ğŸ“ Cargando archivo GeoJSON...');
        const response = await fetch('rutas_transcaribe.geojson');
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        console.log('âœ… Archivo GeoJSON cargado, features:', data.features ? data.features.length : 'undefined');
        
        // Guardar en variable global para la navegaciÃ³n inteligente
        window.rutasTranscaribe = data.features;
        
        if (!data.features || data.features.length === 0) {
          throw new Error('El archivo GeoJSON no contiene features vÃ¡lidas');
        }

        // Filtrar solo paraderos oficiales de Transcaribe
        console.log('ğŸ” Filtrando paraderos de Transcaribe...');
        let paraderos = data.features.filter(f => {
          // Validaciones bÃ¡sicas
          if (!f || !f.geometry || !f.properties) return false;
          if (f.geometry.type !== 'Point') return false;
          
          const props = f.properties;
          const nombre = (props.name || '').toLowerCase();
          
          // PRIORIDAD 1: Filtrar por network: "Transcaribe" (mÃ¡s especÃ­fico)
          if (props.network && props.network.toLowerCase().includes('transcaribe')) {
            console.log(`âœ… Paradero Transcaribe encontrado: ${props.name} (network: ${props.network})`);
            return true;
          }
          
          // PRIORIDAD 2: Filtrar por operator: "Transcaribe"
          if (props.operator && props.operator.toLowerCase().includes('transcaribe')) {
            console.log(`âœ… Paradero Transcaribe encontrado: ${props.name} (operator: ${props.operator})`);
            return true;
          }
          
          // PRIORIDAD 3: Filtrar por highway: "bus_stop" Y public_transport: "platform"
          if (props.highway === 'bus_stop' && props.public_transport === 'platform') {
            console.log(`âœ… Paradero de bus encontrado: ${props.name} (highway: ${props.highway}, public_transport: ${props.public_transport})`);
            return true;
          }
          
          // Excluir elementos que claramente no son de Transcaribe
          const exclusiones = [
            'citysightseeing', 'turÃ­stico', 'turista', 'tourist', 'moto-taxi', 
            'mototaxi', 'taxi', 'uber', 'didi', 'cabify', 'pasacaballos bus',
            'bus para pasacaballos', 'colectivo', 'buseta', 'chiva'
          ];
          if (exclusiones.some(excl => nombre.includes(excl))) {
            console.log(`âŒ Paradero excluido: ${props.name} (contiene palabra excluida)`);
            return false;
          }
          
          return false; // Por defecto, no incluir si no cumple criterios especÃ­ficos
        }).map(f => {
          try {
            return {
              id: f.properties['@id'] || f.id || null,
              nombre: f.properties && f.properties.name ? f.properties.name : 'Sin nombre',
              lat: f.geometry.coordinates[1],
              lon: f.geometry.coordinates[0],
              rutas: Array.isArray(f.properties && f.properties.rutas)
                ? f.properties.rutas
                : (typeof f.properties.rutas === 'string' && f.properties.rutas.length > 0
                    ? f.properties.rutas.split(',').map(r => r.trim())
                    : [])
            };
          } catch (error) {
            return null;
          }
        }).filter(f => f !== null);

        console.log('âœ… Paraderos filtrados encontrados:', paraderos.length);
        if (paraderos.length === 0) {
          console.warn('âš ï¸ No se encontraron paraderos vÃ¡lidos en el archivo GeoJSON');
        }

        // Buscar paraderos cercanos al origen con lÃ³gica avanzada
        console.log('ğŸ“ Buscando paraderos cercanos al origen...');
        // 1. (Opcional) Filtrar por vÃ­a y sentido si la informaciÃ³n estÃ¡ disponible en el GeoJSON
        // Por ejemplo: f.via === viaOrigen && f.sentido === sentidoOrigen
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaOrigen = ...; // Determina la vÃ­a del origen
        // let sentidoOrigen = ...; // Determina el sentido del origen
        // paraderos = paraderos.filter(f => f.via === viaOrigen && f.sentido === sentidoOrigen);

        // 2. Calcular distancia a cada paradero
        let paraderosOrigen = paraderos.map(f => {
          let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 mÃ¡s cercanos dentro del radio

        console.log('ğŸ“ Paraderos cercanos al origen encontrados:', paraderosOrigen.length);

        // Si no hay paraderos vÃ¡lidos, mostrar los 3 mÃ¡s cercanos aunque estÃ©n fuera del radio
        if (paraderosOrigen.length === 0) {
          paraderosOrigen = paraderos
            .map(f => {
              let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let html = '';
        let chipOrigen = '';
        if (start && startMode === 'paradero') {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">ğŸ“ Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (start) {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">ğŸ“ ${obj.nombre}</span>`;
          } catch(e) {}
        }
        if (paraderosOrigen.length === 0) {
          html = '<b>No hay paraderos de Transcaribe cercanos a tu punto de partida.</b><br>Puedes considerar usar otro medio de transporte.';
        } else {
          html = '<b>Paraderos cercanos a tu punto de partida:</b>' + (chipOrigen ? `<div>${chipOrigen}</div>` : '') + '<ul>' + paraderosOrigen.map((p, idx) => {
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            return `<li style="${liStyle}"><b>${p.nombre}</b> (${p.dist.toFixed(0)} m) <br>Rutas: ${(Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas')}</li>`;
          }).join('') + '</ul>';
        }
        document.getElementById('info-paraderos').innerHTML = html;

        // Buscar paraderos cercanos al destino con lÃ³gica avanzada
        console.log('ğŸ¯ Buscando paraderos cercanos al destino...');
        // 1. (Opcional) Filtrar por vÃ­a y sentido si la informaciÃ³n estÃ¡ disponible en el GeoJSON
        // Por ejemplo: f.via === viaDestino && f.sentido === sentidoDestino
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaDestino = ...; // Determina la vÃ­a del destino
        // let sentidoDestino = ...; // Determina el sentido del destino
        // paraderos = paraderos.filter(f => f.via === viaDestino && f.sentido === sentidoDestino);

        // 2. Calcular distancia a cada paradero
        let paraderosDestino = paraderos.map(f => {
          let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 mÃ¡s cercanos dentro del radio

        console.log('ğŸ¯ Paraderos cercanos al destino encontrados:', paraderosDestino.length);

        // Si no hay paraderos vÃ¡lidos, mostrar los 3 mÃ¡s cercanos aunque estÃ©n fuera del radio
        if (paraderosDestino.length === 0) {
          paraderosDestino = paraderos
            .map(f => {
              let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let chipDestino = '';
        if (end && endMode === 'paradero') {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">ğŸ¯ Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (end) {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">ğŸ¯ ${obj.nombre}</span>`;
          } catch(e) {}
        }
        let paraderosHtml = '<b><span style="color:#006400">Paraderos mÃ¡s cercanos a tu destino:</span></b>' + (chipDestino ? `<div>${chipDestino}</div>` : '') + '<ul id="lista-paraderos-destino"></ul>';
        document.getElementById('info-ruta').innerHTML = paraderosHtml;
        if (paraderosDestino.length === 0) {
          document.getElementById('lista-paraderos-destino').innerHTML = '<li>No hay paraderos de Transcaribe cercanos a tu destino. Prueba ampliando el radio de bÃºsqueda o selecciona otro destino.</li>';
        } else {
          let listaHtml = '';
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            listaHtml += `<li id="${liId}" style="${liStyle}">${nombreParadero} (${Math.round(p.dist)} m (lÃ­nea recta))<br>Rutas: ${rutasTxt}</li>`;
          });
          document.getElementById('lista-paraderos-destino').innerHTML = listaHtml;
          // Ahora actualizar la distancia caminando de forma asÃ­ncrona
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            obtenerDistanciaCaminando(endCoords, [p.lat, p.lon]).then(distanciaCaminando => {
              if (distanciaCaminando && !isNaN(distanciaCaminando)) {
                document.getElementById(liId).innerHTML = `${nombreParadero} (${Math.round(distanciaCaminando)} m (a pie))<br>Rutas: ${rutasTxt}`;
              }
            });
          });
        }

        // FunciÃ³n para crear mapas de paraderos cercanos
        async function crearMapasParaderos(paraderosOrigen, paraderosDestino) {
          try {
            console.log('ğŸ—ºï¸ Creando mapa de origen con', paraderosOrigen ? paraderosOrigen.length : 0, 'paraderos');
            // Crear mapa para paraderos de origen
            if (paraderosOrigen && paraderosOrigen.length > 0) {
              const mapaOrigen = L.map('mapa-origen').setView(startCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
              }).addTo(mapaOrigen);
              
              // Agregar marcador del punto de partida
              L.marker(startCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: 'ğŸ“',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaOrigen).bindPopup('<b>Tu punto de partida</b>');
              
              // Colores para las lÃ­neas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosOrigen.slice(0, 3).forEach((paradero, index) => {
                // Marcador del paradero
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: 'ğŸšŒ',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaOrigen).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el punto de partida al paradero
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando(startCoords, [paradero.lat, paradero.lon], mapaOrigen, color, weight, opacity, 'origen');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([startCoords, ...paraderosOrigen.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaOrigen.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aquÃ­, ya estÃ¡ en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de origen
              console.warn('âš ï¸ No hay paraderos de origen para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No se encontraron paraderos cercanos al punto de partida.';
            }
            
            console.log('ğŸ—ºï¸ Creando mapa de destino con', paraderosDestino ? paraderosDestino.length : 0, 'paraderos');
            // Crear mapa para paraderos de destino
            if (paraderosDestino && paraderosDestino.length > 0) {
              const mapaDestino = L.map('mapa-destino').setView(endCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
              }).addTo(mapaDestino);
              
              // Agregar marcador del punto de destino
              L.marker(endCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: 'ğŸ¯',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaDestino).bindPopup('<b>Tu punto de destino</b>');
              
              // Colores para las lÃ­neas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosDestino.slice(0, 3).forEach((paradero, index) => {
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: 'ğŸšŒ',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaDestino).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el paradero al punto de destino
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando([paradero.lat, paradero.lon], endCoords, mapaDestino, color, weight, opacity, 'destino');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([endCoords, ...paraderosDestino.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaDestino.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aquÃ­, ya estÃ¡ en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de destino
              console.warn('âš ï¸ No hay paraderos de destino para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No se encontraron paraderos cercanos al punto de destino.';
            }
          } catch (error) {
            console.error('Error creando mapas:', error);
            document.getElementById('mensaje-error-mapa-origen').innerHTML = 'Error al cargar el mapa de origen: ' + error.message;
            document.getElementById('mensaje-error-mapa-destino').innerHTML = 'Error al cargar el mapa de destino: ' + error.message;
          }
        }
        
        // FunciÃ³n para insertar leyenda en el mapa
        function insertarLeyendaMapa(containerId) {
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const leyenda = document.createElement('div');
          leyenda.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 1000;
            max-width: 150px;
          `;
          leyenda.innerHTML = `
            <div style="margin-bottom: 5px;"><strong>Leyenda:</strong></div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">ğŸ“</span>
              <span>Tu ubicaciÃ³n</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">ğŸ¯</span>
              <span>Tu destino</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">ğŸšŒ</span>
              <span>Paradero</span>
            </div>
            <div style="display: flex; align-items: center;">
              <div style="width: 20px; height: 3px; background: #1ca12d; margin-right: 5px;"></div>
              <span>Ruta caminando</span>
            </div>
          `;
          container.appendChild(leyenda);
        }
        
        // FunciÃ³n para obtener y mostrar rutas caminando
        async function obtenerRutaCaminando(origen, destino, mapa, color, weight = 3, opacity = 0.8, tipo = 'origen') {
          // Forzar color morado oscuro si el color es azul
          if (color === '#007bff' || color === 'blue') color = '#6b46c1';
          const polyline = L.polyline([origen, destino], {
            color: color,
            weight: weight,
            opacity: opacity,
            dashArray: ''
          }).addTo(mapa);
          // Flecha grande a lo largo de toda la lÃ­nea
          if (window.L && window.L.polylineDecorator) {
            L.polylineDecorator(polyline, {
              patterns: [
                {
                  offset: '0%',
                  repeat: 0,
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 48,
                    polygon: false,
                    pathOptions: {stroke: true, color: color, weight: weight + 2, opacity: 1}
                  })
                }
              ]
            }).addTo(mapa);
          }
        }
        
        // Crear mapas de paraderos cercanos
        console.log('ğŸ—ºï¸ Iniciando creaciÃ³n de mapas...');
        await crearMapasParaderos(paraderosOrigen, paraderosDestino);
        console.log('âœ… Mapas creados exitosamente');
        
        // Forzar redibujado de mapas despuÃ©s de un breve delay
        setTimeout(() => {
          const mapaOrigen = document.getElementById('mapa-origen');
          const mapaDestino = document.getElementById('mapa-destino');
          if (mapaOrigen && mapaOrigen._leaflet_map) {
            mapaOrigen._leaflet_map.invalidateSize();
          }
          if (mapaDestino && mapaDestino._leaflet_map) {
            mapaDestino._leaflet_map.invalidateSize();
          }
        }, 500);
        
        // =================== ACTIVAR NAVEGACIÃ“N INTELIGENTE ===================
        console.log('ğŸ§  Activando navegaciÃ³n inteligente automÃ¡ticamente...');
        
        // Verificar si tenemos coordenadas de destino vÃ¡lidas
        if (endCoords && Array.isArray(endCoords) && endCoords.length === 2) {
          console.log('âœ… Coordenadas de destino vÃ¡lidas, iniciando navegaciÃ³n inteligente...');
          
          // Iniciar navegaciÃ³n inteligente automÃ¡ticamente
          iniciarNavegacionInteligente(endCoords);
        } else {
          console.log('âŒ No hay coordenadas de destino vÃ¡lidas para navegaciÃ³n inteligente');
          document.getElementById('info-ruta').innerHTML = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 1rem; color: #856404;"><strong>âš ï¸ NavegaciÃ³n Inteligente:</strong> No se pudo obtener las coordenadas de destino. Por favor, selecciona un destino vÃ¡lido.</div>';
        }
        
      } catch (error) {
        document.getElementById('info-paraderos').innerHTML = '<b>Error procesando la informaciÃ³n:</b> ' + error.message;
      }
    }
    procesarInformacion();
    </script>
    <script>
    // FunciÃ³n para obtener la distancia caminando usando OpenRouteService
    async function obtenerDistanciaCaminando(origen, destino) {
      const apiKey = '5b3ce3597851110001cf6248e92a24fdb4744773ab33cab2c808de44';
      const url = `https://api.openrouteservice.org/v2/directions/foot-walking?api_key=${apiKey}`;
      const body = {
        coordinates: [
          [origen[1], origen[0]], // [lon, lat]
          [destino[1], destino[0]]
        ]
      };
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const data = await response.json();
        if (data && data.features && data.features[0]) {
          return data.features[0].properties.summary.distance; // en metros
        }
        return null;
      } catch (e) {
        console.error('Error consultando ORS:', e);
        return null;
      }
    }
    </script>
    <script>
    let paraderosAuto = [];
    fetch('paraderos.json')
      .then(res => res.json())
      .then(data => {
        paraderosAuto = data;
        inicializarAutocompletado('input-partida', 'sugerencias-partida', 'tuguia_start');
        inicializarAutocompletado('input-destino', 'sugerencias-destino', 'tuguia_end');
      });

    function inicializarAutocompletado(inputId, sugerenciasId, storageKey) {
      const input = document.getElementById(inputId);
      const sugerencias = document.getElementById(sugerenciasId);
      if (!input || !sugerencias) return;
      input.addEventListener('input', function() {
        const texto = input.value.toLowerCase();
        sugerencias.innerHTML = '';
        if (texto.length < 2) return;
        const resultados = paraderosAuto.filter(p => p.nombre.toLowerCase().includes(texto));
        resultados.forEach(p => {
          const div = document.createElement('div');
          div.textContent = p.nombre + ' - ' + p.direccion;
          div.style.cursor = 'pointer';
          div.style.padding = '0.3em 0.5em';
          div.onmouseover = () => div.style.background = '#f0f0ff';
          div.onmouseout = () => div.style.background = '#fff';
          div.onclick = () => {
            input.value = p.nombre;
            sugerencias.innerHTML = '';
            localStorage.setItem(storageKey, JSON.stringify({ nombre: p.nombre, coords: p.coords }));
          };
          sugerencias.appendChild(div);
        });
      });
      input.addEventListener('blur', () => setTimeout(() => sugerencias.innerHTML = '', 200));
    }
    </script>
</div>
<footer class="footer-agapai">
  Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
</footer>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const volverBtn = document.getElementById('volverAGuiaBtn');
  if (volverBtn) {
    volverBtn.addEventListener('click', function() {
      // Limpieza automÃ¡tica de datos de ruta antes de volver
      localStorage.removeItem('tuguia_start');
      localStorage.removeItem('tuguia_end');
      localStorage.removeItem('tuguia_start_mode');
      localStorage.removeItem('tuguia_end_mode');
      window.location.href = 'index.html';
    });
  }
});
</script>
<script>
// Limpieza automÃ¡tica de datos de ruta si el usuario navega hacia atrÃ¡s (flecha del navegador)
window.addEventListener('pagehide', function(e) {
  // Si la navegaciÃ³n es hacia index.html (o cualquier salida de yotellevo.html)
  // Limpiar solo si la pÃ¡gina se estÃ¡ ocultando porque el usuario navega (persisted = false)
  if (!e.persisted) {
    localStorage.removeItem('tuguia_start');
    localStorage.removeItem('tuguia_end');
    localStorage.removeItem('tuguia_start_mode');
    localStorage.removeItem('tuguia_end_mode');
  }
});
</script>
<script>
// FunciÃ³n para mostrar la alerta de proximidad (modal + notificaciÃ³n + vibraciÃ³n)
function mostrarAlertaProximidad() {
  // Mostrar modal llamativo
  var modal = document.getElementById('modal-proximidad');
  if (modal) modal.style.display = 'flex';
  // NotificaciÃ³n del sistema
  if (window.Notification && Notification.permission === 'granted') {
    new Notification('Â¡Faltan menos de 300 metros!', {
      body: 'PrepÃ¡rate para descender en tu destino.',
      icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png' // Ã­cono de bus
    });
  } else if (window.Notification && Notification.permission !== 'denied') {
    Notification.requestPermission().then(function(permission) {
      if (permission === 'granted') {
        new Notification('Â¡Faltan menos de 300 metros!', {
          body: 'PrepÃ¡rate para descender en tu destino.',
          icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
        });
      }
    });
  }
  // VibraciÃ³n si es mÃ³vil
  if (navigator.vibrate) {
    navigator.vibrate([400, 200, 400]);
  }
}
    </script>
    <script>
    // Script adicional para asegurar que los mapas se carguen correctamente
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que los contenedores de mapas existan
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen) {
        console.log('âœ… Contenedor mapa-origen encontrado');
      } else {
        console.error('âŒ Contenedor mapa-origen no encontrado');
      }
      
      if (mapaDestino) {
        console.log('âœ… Contenedor mapa-destino encontrado');
      } else {
        console.error('âŒ Contenedor mapa-destino no encontrado');
      }
      
      // Verificar que Leaflet estÃ© disponible
      if (typeof L !== 'undefined') {
        console.log('âœ… Leaflet cargado correctamente');
      } else {
        console.error('âŒ Leaflet no estÃ¡ disponible');
      }
    });
    
    // FunciÃ³n para forzar el redibujado de mapas
    function redibujarMapas() {
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen && mapaOrigen._leaflet_map) {
        mapaOrigen._leaflet_map.invalidateSize();
        console.log('ğŸ”„ Mapa de origen redibujado');
      }
      
      if (mapaDestino && mapaDestino._leaflet_map) {
        mapaDestino._leaflet_map.invalidateSize();
        console.log('ğŸ”„ Mapa de destino redibujado');
      }
    }
    
    // Redibujar mapas cuando la ventana cambie de tamaÃ±o
    window.addEventListener('resize', redibujarMapas);
    
    // Redibujar mapas despuÃ©s de que la pÃ¡gina se cargue completamente
    window.addEventListener('load', function() {
      setTimeout(redibujarMapas, 1000);
    });
    </script>
</body>
</html> 