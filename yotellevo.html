<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¡Yo te llevo! - Tuguia</title>
    <style>
        body {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            padding: 2rem 0;
        }
  header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      background: linear-gradient(90deg, #4f46e5 0%, #06b6d4 100%);
      color: #fff;
      box-shadow: 0 2px 12px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      padding: 1.2rem 0 0.8rem 0;
      z-index: 1000;
      gap: 1rem;
    }
    .logo {
      width: 70px;
      height: 70px;
      object-fit: contain;
      filter: drop-shadow(0 2px 8px rgba(0,0,0,0.12));
      border-radius: 50%;
      background: #fff;
      padding: 0.3rem;
      margin-bottom: 0;
    }
    h1 {
      font-size: 2.1rem;
      font-weight: 800;
      letter-spacing: 1px;
      margin: 0;
      text-shadow: 0 2px 8px rgba(0,0,0,0.10);
      white-space: nowrap;
    }
    main {
      padding-top: 170px;
      text-align: center;
    }
    @media (max-width: 480px) {
      header {
        padding: 0.8rem 0 0.5rem 0;
        gap: 0.6rem;
      }
      .main-wrapper {
      padding-top: 0px; /* <-- Ajusta este valor según lo que veas en tu móvil */
      }
      .logo {
        width: 48px;
        height: 48px;
      }
      h1 {
        font-size: 3rem;
      }
      
  }
        .main-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            gap: 1rem;
            padding-top: 60px; /* ← Agrega esta línea */
        }
        
        .container {
            background: white;
            border-radius: 22px;
            box-shadow: 0 8px 32px rgba(107,70,193,0.10);
            padding: 2.5rem 2rem 2rem 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        .title {
            font-size: 2rem;
            color: #6b46c1;
            font-weight: 700;
            margin-bottom: 1.2rem;
            letter-spacing: 0.5px;
        }
        .subtitle {
            font-size: 1.1rem;
            color: #4a5568;
            margin-bottom: 2.2rem;
            font-weight: 400;
        }
        .big-icon {
            font-size: 3.5rem;
            margin-bottom: 1.2rem;
            color: #ff6600;
        }
        .main-btn {
            background: linear-gradient(135deg, #6b46c1, #553c9a);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.9rem 2.2rem;
            box-shadow: 0 6px 20px rgba(107,70,193,0.13);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            letter-spacing: 0.5px;
            margin-top: 1.5rem;
        }
        .main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 32px rgba(107,70,193,0.18);
        }
        .info-section {
            margin-top: 2.5rem;
            text-align: left;
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #ff5900;
        }
        .info-section ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .info-section li {
            margin-bottom: 0.5rem;
        }
        .footer-agapai {
            width: 100vw;
            text-align: center;
            padding: 1.2em 0 0.7em 0;
            font-size: 10px;
            color: #6b46c1;
            font-weight: 400;
            letter-spacing: 0.5px;
            position: fixed;
            left: 0;
            bottom: 0;
            background: transparent;
            z-index: 100;
        }
        .footer-agapai a {
            color: #ff6600;
            text-decoration: none;
            font-weight: 400;
        }
        @media (max-width: 600px) {
            .footer-agapai { font-size: 0.95em; padding-bottom: 0.5em; }
        }
        
        /* Estilos para los contenedores de mapas */
        .map-container {
            background: white;
            border-radius: 18px;
            box-shadow: 0 6px 24px rgba(107,70,193,0.08);
            padding: 1.8rem;
            margin: 1rem auto;
            max-width: 600px;
            width: 90%;
        }
        
        .map-title {
            font-size: 1.3rem;
            color: #6b46c1;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
            letter-spacing: 0.3px;
        }
        
        .map-subtitle {
            font-size: 0.9rem;
            color: #718096;
            font-weight: 400;
            padding-top: 1rem;
            text-align: center;
            font-style: italic;
        }
        
        .map-area {
            height: 400px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            border: 1px solid #e2e8f0;
        }
        @media (max-width: 768px) {
            .map-area {
                height: 320px;
            }
        }
    </style>
</head>
<body>
  <header>
    <img src="logoagapai-ok2.png" alt="Logo Yo te llevo" class="logo">
    <h1>¡Yo te llevo!</h1>
  </header>
    <div class="main-wrapper">
        <div class="container">
           
            
          <!-- Nuevo cuadro azul con bordes circulares para la frase -->
          <div style="background: linear-gradient(135deg, #dd8707 0%, #f7ab09 100%); border-radius: 18px; padding: 1.5rem; margin: -2.2rem 0; box-shadow: 0 2px 12px rgba(0,0,0,0.07); text-align: center;height: 65px;">
            <div class="subtitle" style="margin-top: 0; color: #fff; font-size: 1.15rem; font-weight: 500;">
              ¿No sabes cómo llegar a tu destino?<br>
              Te ayudo a encontrar la mejor ruta y te acompaño en el camino.
            </div>
          </div>
            <!-- Panel Tu Guía Inteligente (nuevo contenedor) -->
            <div id="panel-guia-inteligente"></div>
            
          <!-- Panel de paraderos cercanos al destino -->
            <div id="info-paraderos" class="info-section"></div>
            
            <div id="info-ruta" class="info-section"></div>
            <!-- Reemplaza el enlace por un botón funcional para volver a la guía -->
            <button id="volverAGuiaBtn" class="main-btn">Volver a Tu Guía</button>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DE PARTIDA -->
        <div class="map-container">
            <h3 class="map-title">🗺️ Paraderos cercanos a tu Punto de Partida</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>📍 Tu ubicación</span>
              <span>🎯 Tu destino</span>
              <span>🚌 Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-origen" class="map-area"></div>
            <div id="mensaje-error-mapa-origen" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
        
        <!-- CONTENEDOR MAPA PARADEROS CERCANOS AL PUNTO DESTINO -->
        <div class="map-container">
            <h3 class="map-title">🎯 Paraderos cercanos a tu Punto Destino</h3>
            <div class="leyenda-horizontal" style="display:flex;gap:1.2em;align-items:center;justify-content:center;margin:10px 0 18px 0;font-size:13px;">
              <span><strong>Leyenda:</strong></span>
              <span>📍 Tu ubicación</span>
              <span>🎯 Tu destino</span>
              <span>🚌 Paradero</span>
              <span style="display:inline-flex;align-items:center;"><span style="width:20px;height:3px;background:#1ca12d;display:inline-block;margin-right:5px;"></span>Ruta caminando</span>
            </div>
            <p class="map-subtitle">Ruta caminando</p>
            <div id="mapa-destino" class="map-area"></div>
            <div id="mensaje-error-mapa-destino" style="color:#b94a48;font-weight:600;text-align:center;margin-top:0.5em;"></div>
        </div>
    </div>
    
    <!-- Modal de alerta de proximidad -->
    <div id="modal-proximidad" style="display:none;position:fixed;z-index:9999;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);justify-content:center;align-items:center;">
      <div style="background:#fffbe6;border:4px solid #ff9800;border-radius:18px;padding:2em 2em 1.5em 2em;box-shadow:0 8px 32px #0008;text-align:center;max-width:90vw;">
        <div style="font-size:2.2em;color:#ff9800;font-weight:bold;margin-bottom:0.5em;">¡Atención!</div>
        <div style="font-size:1.3em;color:#333;margin-bottom:1em;">Faltan menos de <b>300 metros</b> para llegar a tu destino.<br>Prepárate para descender.</div>
        <button id="btnAlertaEntendido" style="font-size:1.1em;padding:0.5em 1.5em;background:#ff9800;color:#fff;border:none;border-radius:8px;cursor:pointer;">Entendido</button>
      </div>
    </div>
    <footer class="footer-agapai">
        Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
    </footer>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline"></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
    <script>
    // =================== LÓGICA DE NAVEGACIÓN INTELIGENTE ===================
    
    // Variables globales para el seguimiento inteligente
    let isIntelligentTrackingActive = false;
    let intelligentTrackingWatchId = null;
    let intelligentTrackingStartTime = null;
    let intelligentTrackingLastPosition = null;
    let intelligentTrackingDistance = 0;
    let intelligentTrackingAlarmaActivada = false;
    let intelligentTrackingDestino = null;
    let rutaOptimaCalculada = null;
    let paraderoCercanoEncontrado = null;
    
    // Variables globales para alarma/vibración
    let alarmaFinalInterval = null;
    
    // Utilidad para calcular distancia entre dos puntos (Haversine)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Radio de la Tierra en metros
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Función para obtener ubicación GPS
    function obtenerUbicacionGPS() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocalización no soportada'));
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            resolve({
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              accuracy: pos.coords.accuracy
            });
          },
          (error) => {
            reject(new Error(`Error de geolocalización: ${error.message}`));
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          }
        );
      });
    }
    
    // Función para geocodificación inversa (coordenadas a dirección)
    async function obtenerDireccionDesdeCoordenadas(lat, lng) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
        const data = await response.json();
        if (data && data.address) {
          return data; // Devolver el objeto completo
        }
        return null;
      } catch (error) {
        console.error('❌ Error en geocodificación inversa:', error);
        return null;
      }
    }
    
    // Función para encontrar paradero más cercano
    async function encontrarParaderoMasCercano(ubicacionUsuario) {
      if (!window.rutasTranscaribe || !Array.isArray(window.rutasTranscaribe)) {
        console.error('❌ No hay datos de paraderos disponibles');
        return null;
      }
      
      console.log('🔍 === BUSCANDO PARADERO MÁS CERCANO ===');
      console.log('📍 Ubicación usuario:', ubicacionUsuario);
      console.log('📊 Total de features en GeoJSON:', window.rutasTranscaribe.length);
      
      let paraderoMasCercano = null;
      let distanciaMinima = Infinity;
      
      // Filtrar solo paraderos Transcaribe
      const paraderosTranscaribe = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      console.log('🚌 Paraderos Transcaribe encontrados:', paraderosTranscaribe.length);
      
      paraderosTranscaribe.forEach((paradero, index) => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const distancia = haversine(
          ubicacionUsuario.lat, ubicacionUsuario.lng,
          lat, lon
        );
        
        // Log del primer paradero para debugging
        if (index === 0) {
          console.log('🔍 Ejemplo de paradero:', {
            nombre: paradero.properties.nombre_paradero,
            rutas: paradero.properties.rutas,
            network: paradero.properties.network,
            distancia: distancia
          });
        }
        
        if (distancia < distanciaMinima) {
          distanciaMinima = distancia;
          paraderoMasCercano = {
            nombre: paradero.properties.nombre_paradero || 'Paradero',
            lat: lat,
            lon: lon,
            distancia: distancia,
            rutas: paradero.properties.rutas || '',
            tipos_ruta: paradero.properties.tipos_ruta || ''
          };
        }
      });
      
      console.log('📍 Paradero más cercano encontrado:', paraderoMasCercano);
      return paraderoMasCercano;
    }
    
    // Función para verificar ruta directa
    function verificarRutaDirecta(paraderoOrigen, paraderoDestino) {
      console.log('🔍 === VERIFICANDO RUTA DIRECTA ===');
      console.log('📍 Paradero Origen:', paraderoOrigen);
      console.log('🎯 Paradero Destino:', paraderoDestino);
      // Convertir rutas de string a array si es necesario
      const rutasOrigen = typeof paraderoOrigen.rutas === 'string' ? 
        paraderoOrigen.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoOrigen.rutas) ? paraderoOrigen.rutas : []);
      const rutasDestino = typeof paraderoDestino.rutas === 'string' ? 
        paraderoDestino.rutas.split(',').map(r => r.trim()).filter(Boolean) : 
        (Array.isArray(paraderoDestino.rutas) ? paraderoDestino.rutas : []);
      console.log('🚌 Rutas Origen (procesadas):', rutasOrigen);
      console.log('🚌 Rutas Destino (procesadas):', rutasDestino);
      // Buscar intersección
      const rutasComunes = rutasOrigen.filter(ruta => rutasDestino.includes(ruta));
      console.log('🟢 Rutas comunes (intersección):', rutasComunes);
      if (rutasComunes.length > 0) {
        console.log('✅ Ruta directa encontrada:', rutasComunes[0]);
        return { ruta: rutasComunes[0], todas: rutasComunes };
      }
      console.log('❌ No se encontró ruta directa');
      return null;
    }
    
    // Función para encontrar mejor transbordo
    function encontrarMejorTransbordo(paraderoOrigen, paraderoDestino) {
      if (!window.rutasTranscaribe) return null;
      
      // Buscar paraderos que conecten las rutas
      const paraderosTransbordo = window.rutasTranscaribe.filter(f => 
        f.geometry && 
        f.geometry.type === "Point" && 
        f.properties && 
        f.properties.network === "Transcaribe"
      );
      
      let mejorTransbordo = null;
      let mejorScore = Infinity;
      
      paraderosTransbordo.forEach(paradero => {
        const coords = paradero.geometry.coordinates;
        const lat = coords[1];
        const lon = coords[0];
        
        const rutasParadero = typeof paradero.properties.rutas === 'string' ? 
          paradero.properties.rutas.split(',').map(r => r.trim()) : 
          (Array.isArray(paradero.properties.rutas) ? paradero.properties.rutas : []);
        
        // Verificar si este paradero conecta origen y destino
        const rutaDesdeOrigen = verificarRutaDirecta(paraderoOrigen, {
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        });
        
        const rutaHastaDestino = verificarRutaDirecta({
          nombre: paradero.properties.nombre_paradero,
          rutas: rutasParadero
        }, paraderoDestino);
        
        if (rutaDesdeOrigen && rutaHastaDestino) {
          // Calcular score basado en distancia total
          const distOrigenTransbordo = haversine(
            paraderoOrigen.lat, paraderoOrigen.lon,
            lat, lon
          );
          
          const distTransbordoDestino = haversine(
            lat, lon,
            paraderoDestino.lat, paraderoDestino.lon
          );
          
          const score = distOrigenTransbordo + distTransbordoDestino;
          
          if (score < mejorScore) {
            mejorScore = score;
            mejorTransbordo = {
              paraderoTransbordo: {
                nombre: paradero.properties.nombre_paradero,
                lat: lat,
                lon: lon
              },
              ruta1: rutaDesdeOrigen.ruta,
              ruta2: rutaHastaDestino.ruta,
              score: score
            };
          }
        }
      });
      
      return mejorTransbordo;
    }
    
    // Función para calcular ruta óptima
    async function calcularRutaOptima(paraderoOrigen, destinoCoords) {
      if (!destinoCoords) {
        console.error('❌ No hay coordenadas de destino');
        return null;
      }
      // Buscar paradero más cercano al destino
      const paraderoDestino = await encontrarParaderoMasCercano({
        lat: destinoCoords[0],
        lng: destinoCoords[1]
      });
      if (!paraderoDestino) {
        console.error('❌ No se encontró paradero cercano al destino');
        return null;
      }
      // Verificar si hay ruta directa
      const rutaDirecta = verificarRutaDirecta(paraderoOrigen, paraderoDestino);
      console.log('🟢 Resultado de verificarRutaDirecta:', rutaDirecta);
      // Obtener el nombre filtrado del destino para la comparación
      let destinoNombreOriginal = (typeof end === 'string') ? end : (paraderoDestino.nombre || '');
      // --- CORRECCIÓN CLAVE ---
      // Si destinoNombreOriginal es un JSON, extraer solo el campo 'nombre' si existe
      try {
        if (typeof destinoNombreOriginal === 'string' && destinoNombreOriginal.trim().startsWith('{')) {
          const obj = JSON.parse(destinoNombreOriginal);
          if (obj && obj.nombre) {
            destinoNombreOriginal = obj.nombre;
          } else if (obj && obj.display_name) {
            destinoNombreOriginal = obj.display_name;
          } else {
            destinoNombreOriginal = '';
          }
        }
      } catch (e) {
        // Si falla el parseo, dejar el valor como está
      }
      // Asegura que destinoNombreOriginal sea un string legible
      if (typeof destinoNombreOriginal === 'object' && destinoNombreOriginal !== null) {
        if (destinoNombreOriginal.nombre) {
          destinoNombreOriginal = destinoNombreOriginal.nombre;
        } else if (destinoNombreOriginal.display_name) {
          destinoNombreOriginal = destinoNombreOriginal.display_name;
        } else {
          destinoNombreOriginal = '';
        }
      }
      // Normaliza nombres para comparación robusta
      function normalizarTexto(str) {
        return String(str).toLowerCase().normalize('NFD').replace(/[0-\u036f]/g, '').trim();
      }
      const destinoNombreFiltrado = limpiarDireccionParaMostrar(destinoNombreOriginal);
      const nombreParadero = normalizarTexto(paraderoDestino.nombre);
      const nombreDestino = normalizarTexto(destinoNombreFiltrado);
      // Calcular distancia a pie entre el paradero y el destino
      let distanciaAPie = await obtenerDistanciaCaminando([paraderoDestino.lat, paraderoDestino.lon], destinoCoords);
      // --- AJUSTE CLAVE ---
      // Si el destino es una dirección escrita, siempre mostrar la caminata final
      if (rutaDirecta && rutaDirecta.todas && rutaDirecta.todas.length > 0) {
        let rutasTexto = rutaDirecta.todas.length === 1 ? `la ruta ${rutaDirecta.todas[0]}` : `las rutas ${rutaDirecta.todas.join(', ')}`;
        let mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevará directamente a ${paraderoDestino.nombre}.`;
        if (endMode !== 'paradero') {
          // Siempre mostrar caminata si el destino es dirección escrita, sin importar la distancia ni coincidencia de nombres
          mensaje = `Toma ${rutasTexto} en ${paraderoOrigen.nombre}. Te llevará directamente a ${paraderoDestino.nombre}, desde allí te desplazas a pie ${Math.round(distanciaAPie)} metros para llegar a ${destinoNombreFiltrado}.`;
        }
        return {
          tipo: 'directa',
          paraderoOrigen: paraderoOrigen,
          paraderoDestino: paraderoDestino,
          ruta: rutaDirecta.todas,
          mensaje: mensaje,
          pasos: rutaDirecta.todas.map(ruta => ({ accion: 'tomar', ruta: ruta, desde: paraderoOrigen, hasta: paraderoDestino }))
        };
      } else {
        // Buscar transbordo
        const transbordo = encontrarMejorTransbordo(paraderoOrigen, paraderoDestino);
        if (transbordo && transbordo.ruta1 && transbordo.ruta2) {
          let mensaje = `Toma la ruta ${transbordo.ruta1} hasta ${transbordo.paraderoTransbordo.nombre}. Allí cambia a la ruta ${transbordo.ruta2} hasta ${paraderoDestino.nombre}.`;
          if (endMode !== 'paradero') {
            mensaje += ` Desde allí, desplázate a pie ${Math.round(distanciaAPie)} metros para llegar a ${destinoNombreFiltrado}.`;
          }
          return {
            tipo: 'con_transbordo',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            paraderoTransbordo: transbordo.paraderoTransbordo,
            ruta1: transbordo.ruta1,
            ruta2: transbordo.ruta2,
            mensaje: mensaje,
            pasos: [
              { accion: 'tomar', ruta: transbordo.ruta1, desde: paraderoOrigen, hasta: transbordo.paraderoTransbordo },
              { accion: 'transbordar', en: transbordo.paraderoTransbordo },
              { accion: 'tomar', ruta: transbordo.ruta2, desde: transbordo.paraderoTransbordo, hasta: paraderoDestino }
            ]
          };
        } else {
          // Si no hay ruta directa ni transbordo válido, mostrar advertencia
          const mensaje = 'No se encontró una ruta directa ni con transbordo entre los paraderos seleccionados.';
          return {
            tipo: 'sin_ruta',
            paraderoOrigen: paraderoOrigen,
            paraderoDestino: paraderoDestino,
            mensaje: mensaje,
            pasos: []
          };
        }
      }
    }
    
    // Función para mostrar instrucciones inteligentes
    function mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario) {
      // Determinar el texto del punto de partida
      let puntoPartida = '';
      let start = localStorage.getItem('tuguia_start') || '';
      let startMode = localStorage.getItem('tuguia_start_mode') || '';
      try {
        let obj = start;
        if (typeof start === 'string' && start.trim().startsWith('{')) {
          obj = JSON.parse(start);
        }
        if (startMode === 'paradero') {
          puntoPartida = obj.nombre || 'Paradero seleccionado';
        } else if (startMode === 'direccion') {
          puntoPartida = obj.nombre || obj.direccion || '';
          if (!puntoPartida && typeof obj === 'string') {
            puntoPartida = obj;
          }
          if (!puntoPartida && obj.coords) {
            puntoPartida = obj.coords.join(', ');
          }
          if (!puntoPartida) {
            puntoPartida = 'Dirección seleccionada';
          }
        } else {
          puntoPartida = (typeof obj === 'string') ? obj : (obj.nombre || obj.direccion || 'No disponible');
        }
        if (typeof puntoPartida === 'string') {
          puntoPartida = limpiarDireccionParaMostrar(puntoPartida);
        }
      } catch(e) {
        puntoPartida = 'No disponible';
      }
      let instruccionesHTML = `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 18px; padding: 1.7rem 1.3rem 1.3rem 1.3rem; margin: 1.2rem 0; box-shadow: 0 2px 16px rgba(44,62,80,0.10); color: #fff; max-width: 420px;">
          <h3 style="margin: 0 0 1.1rem 0; font-size: 1.35rem; color: #fff; font-weight: 700; letter-spacing: 0.5px;">🧠 Tu Guía Inteligente</h3>
          <div style="margin-bottom: 1rem; font-size: 1.05rem; display: flex; align-items: center; gap: 8px;">
            <span style='font-size:1.2em;'>📍</span> <strong>Punto de Partida:</strong> <span style='color:#ffe082;'>${puntoPartida}</span>
          </div>
          <div style="margin-bottom: 1rem; font-size: 1.05rem; display: flex; align-items: center; gap: 8px;">
            <span style='font-size:1.2em;'>🚌</span> <strong>Paradero más cercano:</strong> <span style='color:#ffe082;'>${paraderoCercano.nombre} (${Math.round(paraderoCercano.distancia)}m)</span>
          </div>
          <div style="background: rgba(255,255,255,0.18); color: #fff; padding: 1.1rem 1rem; border-radius: 12px; margin-bottom: 1.2rem; font-size: 1.07rem;">
            <strong style='display:flex;align-items:center;gap:7px;'><span style='font-size:1.2em;'>📋</span> Instrucciones:</strong>
            <div style='margin-top:0.5em;'>${rutaOptima.mensaje}</div>
          </div>
          <button id="btnIniciarSeguimiento" style="background: linear-gradient(90deg, #ff6600 60%, #ff9800 100%); color: #fff; border: none; border-radius: 10px; padding: 0.85em 1.7em; font-size: 1.08em; font-weight: 600; cursor: pointer; box-shadow: 0 2px 8px rgba(255,102,0,0.13); display: flex; align-items: center; gap: 8px; margin: 0 auto;">
            <span style='font-size:1.2em;'>🚀</span> Iniciar Seguimiento Inteligente
          </button>
        </div>
      `;
      const panelGuia = document.getElementById('panel-guia-inteligente');
      if (panelGuia) {
        panelGuia.innerHTML = instruccionesHTML;
        // Asociar funcionalidad al botón
        const btn = document.getElementById('btnIniciarSeguimiento');
        if (btn) {
          btn.addEventListener('click', function() {
            iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario);
          });
        }
      }
      console.log('📋 Instrucciones inteligentes mostradas:', rutaOptima.mensaje);
    }
    
    // Función para iniciar seguimiento inteligente
    function iniciarSeguimientoInteligente(rutaOptima, paraderoCercano, ubicacionUsuario) {
      if (isIntelligentTrackingActive) return;
      
      isIntelligentTrackingActive = true;
      intelligentTrackingDistance = 0;
      intelligentTrackingAlarmaActivada = false;
      intelligentTrackingStartTime = Date.now();
      intelligentTrackingLastPosition = null;
      intelligentTrackingDestino = [rutaOptima.paraderoDestino.lat, rutaOptima.paraderoDestino.lon];
      rutaOptimaCalculada = rutaOptima;
      paraderoCercanoEncontrado = paraderoCercano;
      
      // Crear panel de seguimiento flotante fijo
      const seguimientoHTML = `
        <div id="panel-seguimiento-flotante" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; background: #fffbe6; border: 2.5px solid #007bff; border-radius: 14px; padding: 1.2rem; box-shadow: 0 4px 20px rgba(0,0,0,0.15), 0 2px 10px rgba(0,123,255,0.2); max-width: 90vw; min-width: 320px; backdrop-filter: blur(10px);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem;">
            <h4 style="margin: 0; color: #007bff; font-size: 1.1rem;">🚀 Seguimiento Activo</h4>
            <button id="minimizarSeguimientoBtn" style="background: #6c757d; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
              📱
            </button>
          </div>
          <div style="background: #ffe9b3; color: #b26a00; border-radius: 6px; padding: 6px 0; margin-bottom: 10px; font-weight: 600; font-size: 1rem; text-align: center; box-shadow: 0 1px 4px rgba(33,136,56,0.07);">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <span style="font-size:1.2em;">🟢</span> ¡Guiado en tiempo real!
            </span>
          </div>
          <div id="leyenda-barrio" style="font-size:1em;color:#6b46c1;font-weight:600;margin-bottom:0.6em;"></div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem; margin-bottom: 0.8rem; font-size: 0.9rem;">
            <div>
              <strong>📏 Distancia:</strong><br>
              <span id="distanciaRecorrida">0.0 km</span>
            </div>
            <div>
              <strong>⏱️ Tiempo:</strong><br>
              <span id="tiempoTranscurrido">00:00</span>
            </div>
            <div>
              <strong>🚶 Velocidad:</strong><br>
              <span id="velocidadActual">0.0 km/h</span>
            </div>
            <div>
              <strong>📍 Estado:</strong><br>
              <span id="estadoSeguimiento">📍 Iniciando...</span>
            </div>
          </div>
          <div style="background: #e9ecef; border-radius: 6px; padding: 0.4rem; margin-bottom: 0.8rem;">
            <div style="background: #007bff; height: 6px; border-radius: 3px; width: 0%; transition: width 0.3s;" id="barraProgreso"></div>
          </div>
          <button id="detenerSeguimientoBtn" style="background: #dc3545; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; width: 100%; font-weight: 600;">
            ⏹️ Detener Seguimiento
          </button>
        </div>
      `;
      
      // Crear el panel flotante
      let panelFlotante = document.getElementById('panel-seguimiento-flotante');
      if (!panelFlotante) {
        // Crear el elemento si no existe
        panelFlotante = document.createElement('div');
        panelFlotante.id = 'panel-seguimiento-flotante';
        document.body.appendChild(panelFlotante);
      }
      
      // Insertar el contenido del panel
      panelFlotante.innerHTML = seguimientoHTML;
      
      // Agregar event listeners
      setTimeout(() => {
        const btnDetener = document.getElementById('detenerSeguimientoBtn');
        const btnMinimizar = document.getElementById('minimizarSeguimientoBtn');
        
        if (btnDetener) {
          btnDetener.addEventListener('click', detenerSeguimientoInteligente);
        }
        
        if (btnMinimizar) {
          btnMinimizar.addEventListener('click', function() {
            const panel = document.getElementById('panel-seguimiento-flotante');
            if (panel) {
              panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
              btnMinimizar.textContent = panel.style.display === 'none' ? '📱' : '📱';
            }
          });
        }
      }, 100);
      
      // Iniciar seguimiento de ubicación
      if (intelligentTrackingWatchId) navigator.geolocation.clearWatch(intelligentTrackingWatchId);
      
      intelligentTrackingWatchId = navigator.geolocation.watchPosition(
        function(pos) {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const current = L.latLng(lat, lon);
          
          // Calcular distancia recorrida
          if (intelligentTrackingLastPosition) {
            const d = intelligentTrackingLastPosition.distanceTo(current);
            if (d > 2) { // Solo sumar si el movimiento es real (>2m)
              intelligentTrackingDistance += d;
            }
          }
          intelligentTrackingLastPosition = current;
          
          // Actualizar UI
          document.getElementById('distanciaRecorrida').textContent = (intelligentTrackingDistance / 1000).toFixed(2) + ' km';
          
          // Actualizar tiempo
          const elapsed = (Date.now() - intelligentTrackingStartTime) / 1000;
          const min = Math.floor(elapsed / 60);
          const sec = Math.floor(elapsed % 60);
          document.getElementById('tiempoTranscurrido').textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
          
          // Calcular velocidad
          const speedKmh = pos.coords.speed && pos.coords.speed > 0 ? (pos.coords.speed * 3.6) : (intelligentTrackingDistance / elapsed) * 3.6;
          document.getElementById('velocidadActual').textContent = speedKmh > 0 ? speedKmh.toFixed(1) + ' km/h' : '0.0 km/h';
          
          // Estado
          const estadoElement = document.getElementById('estadoSeguimiento');
          if (speedKmh > 0.5) {
            estadoElement.textContent = '🟢 En movimiento';
            estadoElement.style.color = '#28a745';
          } else {
            estadoElement.textContent = '⏸️ Detenido';
            estadoElement.style.color = '#dc3545';
          }
          
          // Barra de progreso
          if (intelligentTrackingDestino) {
            const distRestante = current.distanceTo(L.latLng(intelligentTrackingDestino[0], intelligentTrackingDestino[1]));
            let totalDist = intelligentTrackingDistance + distRestante;
            let progress = totalDist > 0 ? (intelligentTrackingDistance / totalDist) * 100 : 0;
            document.getElementById('barraProgreso').style.width = progress + '%';
            
            // Alarma a 300m
            if (!intelligentTrackingAlarmaActivada && distRestante <= 300 && distRestante > 30) {
              intelligentTrackingAlarmaActivada = true;
              mostrarAlertaProximidad();
            }
            // === NUEVO: Detener automáticamente al llegar al destino ===
            if (distRestante <= 30 && isIntelligentTrackingActive) {
              detenerSeguimientoInteligente();
            }
          }
          
          // Actualizar leyenda de barrio
          obtenerDireccionDesdeCoordenadas(lat, lon).then(data => {
            let barrio = '';
            if (data && data.address) {
              barrio = data.address.suburb || data.address.neighbourhood || data.address.quarter || data.address.city_district || data.address.city || '';
              if (!barrio && data.display_name) {
                barrio = data.display_name.split(',')[0];
              }
            }
            document.getElementById('leyenda-barrio').textContent = barrio ? `Vamos Por: ${barrio}` : '';
          });
        },
        function(error) {
          console.error('Error en seguimiento inteligente:', error);
          document.getElementById('estadoSeguimiento').textContent = '❌ Error de GPS';
          document.getElementById('estadoSeguimiento').style.color = '#dc3545';
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 60000
        }
      );
      
      console.log('🚀 Seguimiento inteligente iniciado');
    }
    
    // Función para detener seguimiento inteligente
    function detenerSeguimientoInteligente() {
      if (intelligentTrackingWatchId) {
        navigator.geolocation.clearWatch(intelligentTrackingWatchId);
        intelligentTrackingWatchId = null;
      }
      
      isIntelligentTrackingActive = false;
      
      // Mostrar resumen en el panel flotante
      const resumenHTML = `
        <div style="background: #d4edda; border: 2.5px solid #28a745; border-radius: 14px; padding: 1.2rem; box-shadow: 0 4px 20px rgba(0,0,0,0.15), 0 2px 10px rgba(40,167,69,0.2); max-width: 90vw; min-width: 320px; backdrop-filter: blur(10px);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem;">
            <h4 style="margin: 0; color: #155724; font-size: 1.1rem;">✅ Recorrido Finalizado</h4>
            <button id="cerrarResumenBtn" style="background: #6c757d; color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
              ✕
            </button>
          </div>
          <div style="background: #c3e6cb; color: #155724; border-radius: 6px; padding: 6px 0; margin-bottom: 10px; font-weight: 600; font-size: 1rem; text-align: center;">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <span style="font-size:1.2em;">🎉</span> ¡Llegaste a tu destino!
            </span>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem; margin-bottom: 0.8rem; font-size: 0.9rem;">
            <div>
              <strong>📏 Distancia total:</strong><br>
              <span>${(intelligentTrackingDistance / 1000).toFixed(2)} km</span>
            </div>
            <div>
              <strong>⏱️ Tiempo total:</strong><br>
              <span>${document.getElementById('tiempoTranscurrido').textContent}</span>
            </div>
          </div>
          <button id="btnNuevoSeguimiento" style="background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; width: 100%; font-weight: 600;">
            🔄 Iniciar Nuevo Seguimiento
          </button>
        </div>
      `;
      
      // Actualizar el panel flotante con el resumen
      const panelFlotante = document.getElementById('panel-seguimiento-flotante');
      if (panelFlotante) {
        panelFlotante.innerHTML = resumenHTML;
        
        // Agregar event listeners para los botones del resumen
        setTimeout(() => {
          const btnNuevo = document.getElementById('btnNuevoSeguimiento');
          const btnCerrar = document.getElementById('cerrarResumenBtn');
          
          if (btnNuevo) {
            btnNuevo.addEventListener('click', function() {
              // Limpiar el panel flotante
              if (panelFlotante) {
                panelFlotante.remove();
              }
              // Aquí podrías reiniciar el seguimiento si es necesario
            });
          }
          
          if (btnCerrar) {
            btnCerrar.addEventListener('click', function() {
              if (panelFlotante) {
                panelFlotante.remove();
              }
            });
          }
        }, 100);
      }
        // Activar alarma y vibración muy molesta
        detenerAlarmaFinal(); // Por si acaso ya hay una activa
        alarmaFinalInterval = setInterval(() => {
          // Vibración muy molesta: vibrar 1.2s, pausa 200ms, repetir 6 veces
          if (navigator.vibrate) navigator.vibrate([1200,200,1200,200,1200,200,1200,200,1200,200,1200]);
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'sine';
            o.frequency.value = 880;
            o.connect(g); g.connect(ctx.destination);
            g.gain.value = 0.2;
            o.start();
            setTimeout(()=>{g.gain.value=0; o.stop(); ctx.close();}, 500);
          } catch(e) {}
        }, 2200);
        // Botón para detener alarma y vibración
        setTimeout(() => {
          const btn = document.getElementById('btnNuevoSeguimiento');
          if (btn) {
            btn.onclick = function() {
              detenerAlarmaFinal();
              window.location.reload();
            };
          }
        }, 100);
      }
    }
    
    function detenerAlarmaFinal() {
      if (alarmaFinalInterval) {
        clearInterval(alarmaFinalInterval);
        alarmaFinalInterval = null;
      }
      if (navigator.vibrate) navigator.vibrate(0);
    }
    
    // Función principal de navegación inteligente
    async function iniciarNavegacionInteligente(destinoCoords) {
      try {
        console.log('🧠 Iniciando navegación inteligente...');
        
        // 1. Obtener ubicación GPS actual
        const ubicacionUsuario = await obtenerUbicacionGPS();
        if (!ubicacionUsuario) {
          console.error('❌ No se pudo obtener ubicación GPS');
          return;
        }
        
        // 2. Encontrar paradero más cercano automáticamente
        const paraderoCercano = await encontrarParaderoMasCercano(ubicacionUsuario);
        if (!paraderoCercano) {
          console.error('❌ No se encontró paradero cercano');
          return;
        }
        
        // 3. Calcular ruta óptima automáticamente
        const rutaOptima = await calcularRutaOptima(paraderoCercano, destinoCoords);
        if (!rutaOptima) {
          console.error('❌ No se pudo calcular ruta óptima');
          return;
        }
        
        // 4. Mostrar instrucciones inteligentes
        mostrarInstruccionesInteligentes(rutaOptima, paraderoCercano, ubicacionUsuario);
        
      } catch (error) {
        console.error('❌ Error en navegación inteligente:', error);
      }
    }
    // Función para procesar el nombre del paradero
    function procesarNombreParadero(nombreCompleto) {
      if (!nombreCompleto) return { nombreParadero: 'Sin nombre', ruta: '' };
      
      const match = nombreCompleto.match(/^([A-Z]\d+[A-Z]?)\s+para\s+(.+)$/i);
      if (match) {
        return {
          nombreParadero: match[2].trim(),
          ruta: match[1].trim()
        };
      }
      
      return {
        nombreParadero: nombreCompleto,
        ruta: ''
      };
    }
    // Geocodificación con timeout
    async function geocodificarDireccion(direccion, timeoutMs = 7000) {
      return Promise.race([
        (async () => {
          try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(direccion + ', Cartagena, Colombia')}&limit=1`);
            const data = await response.json();
            if (data.length > 0) {
              return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
            }
            return null;
          } catch (error) {
            console.error('Error geocodificando:', error);
            return null;
          }
        })(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Geocodificación muy lenta o sin respuesta')), timeoutMs))
      ]);
    }
    // Leer puntos de partida y destino
    let start = localStorage.getItem('tuguia_start') || '';
    let end = localStorage.getItem('tuguia_end') || '';
    let startMode = localStorage.getItem('tuguia_start_mode') || '';
    let endMode = localStorage.getItem('tuguia_end_mode') || '';
    
    console.log('📋 Datos recibidos del localStorage:', { start, end, startMode, endMode });
    console.log('🟢 Valor bruto de tuguia_start:', start);
    
    function extraerCoords(str) {
      if (!str) return null;
      try {
        const obj = JSON.parse(str);
        if (obj && Array.isArray(obj.coords)) return obj.coords;
      } catch (e) {}
      let match = str.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
      if (match) return [parseFloat(match[1]), parseFloat(match[2])];
      return null;
    }
    
    let startCoords = extraerCoords(start);
    let endCoords = extraerCoords(end);

    // LOGS DE DEPURACIÓN
    console.log('🟢 Coordenadas extraídas de tuguia_start:', startCoords);
    console.log('🟢 Valor bruto de tuguia_end:', end);
    console.log('🟢 Coordenadas extraídas de tuguia_end:', endCoords);
    
    async function procesarInformacion() {
      try {
        console.log('🚀 Iniciando procesamiento de información...');
        console.log('📍 Start:', start, 'Mode:', startMode, 'Coords:', startCoords);
        console.log('🎯 End:', end, 'Mode:', endMode, 'Coords:', endCoords);

        // Refuerzo: Si ya existen coordenadas, úsalas directamente y no busques ni geocodifiques
        if (!startCoords || !endCoords) {
          console.error('❌ Coordenadas faltantes:', { startCoords, endCoords });
          document.getElementById('info-paraderos').innerHTML = '<b>No se pudo obtener las coordenadas del punto de partida o destino.</b><br>Por favor, selecciona ambos puntos en el mapa o en la lista.';
          document.getElementById('info-ruta').innerHTML = '';
          // Mostrar mensajes de error en los mapas también
          document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No hay coordenadas de origen disponibles.';
          document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No hay coordenadas de destino disponibles.';
          return;
        }

        console.log('✅ Coordenadas válidas encontradas:', { startCoords, endCoords });

        // Cargar archivo GeoJSON
        console.log('📁 Cargando archivo GeoJSON...');
        const response = await fetch('rutas_transcaribe.geojson');
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        console.log('✅ Archivo GeoJSON cargado, features:', data.features ? data.features.length : 'undefined');
        
        // Guardar en variable global para la navegación inteligente
        window.rutasTranscaribe = data.features;
        
        if (!data.features || data.features.length === 0) {
          throw new Error('El archivo GeoJSON no contiene features válidas');
        }

        // Filtrar solo paraderos oficiales de Transcaribe
        console.log('🔍 Filtrando paraderos de Transcaribe...');
        let paraderos = data.features.filter(f => {
          // Validaciones básicas
          if (!f || !f.geometry || !f.properties) return false;
          if (f.geometry.type !== 'Point') return false;
          
          const props = f.properties;
          const nombre = (props.name || '').toLowerCase();
          
          // PRIORIDAD 1: Filtrar por network: "Transcaribe" (más específico)
          if (props.network && props.network.toLowerCase().includes('transcaribe')) {
            console.log(`✅ Paradero Transcaribe encontrado: ${props.name} (network: ${props.network})`);
            return true;
          }
          
          // PRIORIDAD 2: Filtrar por operator: "Transcaribe"
          if (props.operator && props.operator.toLowerCase().includes('transcaribe')) {
            console.log(`✅ Paradero Transcaribe encontrado: ${props.name} (operator: ${props.operator})`);
            return true;
          }
          
          // PRIORIDAD 3: Filtrar por highway: "bus_stop" Y public_transport: "platform"
          if (props.highway === 'bus_stop' && props.public_transport === 'platform') {
            console.log(`✅ Paradero de bus encontrado: ${props.name} (highway: ${props.highway}, public_transport: ${props.public_transport})`);
            return true;
          }
          
          // Excluir elementos que claramente no son de Transcaribe
          const exclusiones = [
            'citysightseeing', 'turístico', 'turista', 'tourist', 'moto-taxi', 
            'mototaxi', 'taxi', 'uber', 'didi', 'cabify', 'pasacaballos bus',
            'bus para pasacaballos', 'colectivo', 'buseta', 'chiva'
          ];
          if (exclusiones.some(excl => nombre.includes(excl))) {
            console.log(`❌ Paradero excluido: ${props.name} (contiene palabra excluida)`);
            return false;
          }
          
          return false; // Por defecto, no incluir si no cumple criterios específicos
        }).map(f => {
          try {
            return {
              id: f.properties['@id'] || f.id || null,
              nombre: f.properties && f.properties.name ? f.properties.name : 'Sin nombre',
              lat: f.geometry.coordinates[1],
              lon: f.geometry.coordinates[0],
              rutas: Array.isArray(f.properties && f.properties.rutas)
                ? f.properties.rutas
                : (typeof f.properties.rutas === 'string' && f.properties.rutas.length > 0
                    ? f.properties.rutas.split(',').map(r => r.trim())
                    : [])
            };
          } catch (error) {
            return null;
          }
        }).filter(f => f !== null);

        console.log('✅ Paraderos filtrados encontrados:', paraderos.length);
        if (paraderos.length === 0) {
          console.warn('⚠️ No se encontraron paraderos válidos en el archivo GeoJSON');
        }

        // Buscar paraderos cercanos al origen con lógica avanzada
        console.log('📍 Buscando paraderos cercanos al origen...');
        // 1. (Opcional) Filtrar por vía y sentido si la información está disponible en el GeoJSON
        // Por ejemplo: f.via === viaOrigen && f.sentido === sentidoOrigen
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaOrigen = ...; // Determina la vía del origen
        // let sentidoOrigen = ...; // Determina el sentido del origen
        // paraderos = paraderos.filter(f => f.via === viaOrigen && f.sentido === sentidoOrigen);

        // 2. Calcular distancia a cada paradero
        let paraderosOrigen = paraderos.map(f => {
          let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 más cercanos dentro del radio

        console.log('📍 Paraderos cercanos al origen encontrados:', paraderosOrigen.length);

        // Si no hay paraderos válidos, mostrar los 3 más cercanos aunque estén fuera del radio
        if (paraderosOrigen.length === 0) {
          paraderosOrigen = paraderos
            .map(f => {
              let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let html = '';
        let chipOrigen = '';
        if (start && startMode === 'paradero') {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">📍 Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (start) {
          try {
            const obj = typeof start === 'string' ? JSON.parse(start) : start;
            chipOrigen = `<span style="display:inline-block;background:#f3f0ff;color:#6b46c1;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #6b46c122;margin-bottom:3px;">📍 ${obj.nombre}</span>`;
          } catch(e) {}
        }
        if (paraderosOrigen.length === 0) {
          html = '<b>No hay paraderos de Transcaribe cercanos a tu punto de partida.</b><br>Puedes considerar usar otro medio de transporte.';
        } else {
          html = '<b>Paraderos cercanos a tu punto de partida:</b>' + (chipOrigen ? `<div>${chipOrigen}</div>` : '') + '<ul>' + paraderosOrigen.map((p, idx) => {
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            return `<li style="${liStyle}"><b>${p.nombre}</b> (${p.dist.toFixed(0)} m) <br>Rutas: ${(Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas')}</li>`;
          }).join('') + '</ul>';
        }
        document.getElementById('info-paraderos').innerHTML = html;

        // Buscar paraderos cercanos al destino con lógica avanzada
        console.log('🎯 Buscando paraderos cercanos al destino...');
        // 1. (Opcional) Filtrar por vía y sentido si la información está disponible en el GeoJSON
        // Por ejemplo: f.via === viaDestino && f.sentido === sentidoDestino
        // Si tu GeoJSON tiene campos como 'via' o 'sentido', descomenta y ajusta:
        // let viaDestino = ...; // Determina la vía del destino
        // let sentidoDestino = ...; // Determina el sentido del destino
        // paraderos = paraderos.filter(f => f.via === viaDestino && f.sentido === sentidoDestino);

        // 2. Calcular distancia a cada paradero
        let paraderosDestino = paraderos.map(f => {
          let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
          let rutas = Array.isArray(f.rutas) ? f.rutas : [];
          let nombreInfo = procesarNombreParadero(f.nombre);
          if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
          return {
            nombre: nombreInfo.nombreParadero,
            ruta: nombreInfo.ruta,
            dist,
            rutas,
            lat: f.lat,
            lon: f.lon,
            id: f.id
          };
        })
        .filter(p => p.dist >= 50)
        .filter(p => p.dist <= 500)
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 3); // <-- Mostrar solo los 3 más cercanos dentro del radio

        console.log('🎯 Paraderos cercanos al destino encontrados:', paraderosDestino.length);

        // Si no hay paraderos válidos, mostrar los 3 más cercanos aunque estén fuera del radio
        if (paraderosDestino.length === 0) {
          paraderosDestino = paraderos
            .map(f => {
              let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
              let rutas = Array.isArray(f.rutas) ? f.rutas : [];
              let nombreInfo = procesarNombreParadero(f.nombre);
              if (rutas.length === 0 && nombreInfo.ruta) rutas = [nombreInfo.ruta];
              return {
                nombre: nombreInfo.nombreParadero,
                ruta: nombreInfo.ruta,
                dist,
                rutas,
                lat: f.lat,
                lon: f.lon,
                id: f.id
              };
            })
            .filter(p => p.dist >= 50)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        }
        let chipDestino = '';
        if (end && endMode === 'paradero') {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">🎯 Paradero: ${obj.nombre}</span>`;
          } catch(e) {}
        } else if (end) {
          try {
            const obj = typeof end === 'string' ? JSON.parse(end) : end;
            chipDestino = `<span style="display:inline-block;background:#fffbe6;color:#b36b00;font-weight:600;border-radius:13px;padding:2px 8px;font-size:0.82em;box-shadow:0 1px 4px #ff980022;margin-bottom:3px;">🎯 ${obj.nombre}</span>`;
          } catch(e) {}
        }
        let paraderosHtml = '<b><span style="color:#006400">Paraderos más cercanos a tu destino:</span></b>' + (chipDestino ? `<div>${chipDestino}</div>` : '') + '<ul id="lista-paraderos-destino"></ul>';
        document.getElementById('info-ruta').innerHTML = paraderosHtml;
        if (paraderosDestino.length === 0) {
          document.getElementById('lista-paraderos-destino').innerHTML = '<li>No hay paraderos de Transcaribe cercanos a tu destino. Prueba ampliando el radio de búsqueda o selecciona otro destino.</li>';
        } else {
          let listaHtml = '';
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let liStyle = idx === 0 ? 'background:#e6ffe6;border-left:5px solid #1ca12d;padding:0.5em 0.5em 0.5em 1em;margin-bottom:0.5em;' : '';
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            listaHtml += `<li id="${liId}" style="${liStyle}">${nombreParadero} (${Math.round(p.dist)} m (línea recta))<br>Rutas: ${rutasTxt}</li>`;
          });
          document.getElementById('lista-paraderos-destino').innerHTML = listaHtml;
          // Ahora actualizar la distancia caminando de forma asíncrona
          paraderosDestino.forEach((p, idx) => {
            let liId = `paradero-destino-${idx}`;
            let rutasTxt = (Array.isArray(p.rutas) && p.rutas.length ? p.rutas.join(', ') : 'Sin rutas');
            let nombreParadero = p.nombre;
            if (p.ruta) {
              nombreParadero = `<b>${p.ruta}</b> - ${p.nombre}`;
            }
            obtenerDistanciaCaminando(endCoords, [p.lat, p.lon]).then(distanciaCaminando => {
              if (distanciaCaminando && !isNaN(distanciaCaminando)) {
                document.getElementById(liId).innerHTML = `${nombreParadero} (${Math.round(distanciaCaminando)} m (a pie))<br>Rutas: ${rutasTxt}`;
              }
            });
          });
        }

        // Función para crear mapas de paraderos cercanos
        async function crearMapasParaderos(paraderosOrigen, paraderosDestino) {
          try {
            console.log('🗺️ Creando mapa de origen con', paraderosOrigen ? paraderosOrigen.length : 0, 'paraderos');
            // Crear mapa para paraderos de origen
            if (paraderosOrigen && paraderosOrigen.length > 0) {
              const mapaOrigen = L.map('mapa-origen').setView(startCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
              }).addTo(mapaOrigen);
              
              // Agregar marcador del punto de partida
              L.marker(startCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: '📍',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaOrigen).bindPopup('<b>Tu punto de partida</b>');
              
              // Colores para las líneas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosOrigen.slice(0, 3).forEach((paradero, index) => {
                // Marcador del paradero
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: '🚌',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaOrigen).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el punto de partida al paradero
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando(startCoords, [paradero.lat, paradero.lon], mapaOrigen, color, weight, opacity, 'origen');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([startCoords, ...paraderosOrigen.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaOrigen.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aquí, ya está en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de origen
              console.warn('⚠️ No hay paraderos de origen para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-origen').innerHTML = 'No se encontraron paraderos cercanos al punto de partida.';
            }
            
            console.log('🗺️ Creando mapa de destino con', paraderosDestino ? paraderosDestino.length : 0, 'paraderos');
            // Crear mapa para paraderos de destino
            if (paraderosDestino && paraderosDestino.length > 0) {
              const mapaDestino = L.map('mapa-destino').setView(endCoords, 15);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
              }).addTo(mapaDestino);
              
              // Agregar marcador del punto de destino
              L.marker(endCoords, {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: '🎯',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30]
                })
              }).addTo(mapaDestino).bindPopup('<b>Tu punto de destino</b>');
              
              // Colores para las líneas
              const colores = ['#1ca12d', '#007bff', '#ff6600'];
              // Agregar paraderos cercanos y rutas
              paraderosDestino.slice(0, 3).forEach((paradero, index) => {
                const color = colores[index % colores.length];
                L.marker([paradero.lat, paradero.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker',
                    html: '🚌',
                    iconSize: [25, 25],
                    iconAnchor: [12, 25]
                  })
                }).addTo(mapaDestino).bindPopup(
                  `<div style="border-top:5px solid ${color};padding-top:4px;"><b>${paradero.nombre}</b><br>Distancia: ${Math.round(paradero.dist)}m<br>Rutas: ${paradero.rutas.join(', ')}</div>`
                );
                
                // Ruta desde el paradero al punto de destino
                const weight = index === 0 ? 6 : 3;
                const opacity = index === 0 ? 1 : 0.7;
                obtenerRutaCaminando([paradero.lat, paradero.lon], endCoords, mapaDestino, color, weight, opacity, 'destino');
              });
              
              // Ajustar vista para mostrar todos los puntos
              const bounds = L.latLngBounds([endCoords, ...paraderosDestino.slice(0, 3).map(p => [p.lat, p.lon])]);
              mapaDestino.fitBounds(bounds, { padding: [20, 20] });
              // No insertar leyenda aquí, ya está en el HTML
            } else {
              // Mostrar mensaje de error si no hay paraderos de destino
              console.warn('⚠️ No hay paraderos de destino para mostrar en el mapa');
              document.getElementById('mensaje-error-mapa-destino').innerHTML = 'No se encontraron paraderos cercanos al punto de destino.';
            }
          } catch (error) {
            console.error('Error creando mapas:', error);
            document.getElementById('mensaje-error-mapa-origen').innerHTML = 'Error al cargar el mapa de origen: ' + error.message;
            document.getElementById('mensaje-error-mapa-destino').innerHTML = 'Error al cargar el mapa de destino: ' + error.message;
          }
        }
        
        // Función para insertar leyenda en el mapa
        function insertarLeyendaMapa(containerId) {
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const leyenda = document.createElement('div');
          leyenda.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 1000;
            max-width: 150px;
          `;
          leyenda.innerHTML = `
            <div style="margin-bottom: 5px;"><strong>Leyenda:</strong></div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">📍</span>
              <span>Tu ubicación</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">🎯</span>
              <span>Tu destino</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 3px;">
              <span style="font-size: 20px; margin-right: 5px;">🚌</span>
              <span>Paradero</span>
            </div>
            <div style="display: flex; align-items: center;">
              <div style="width: 20px; height: 3px; background: #1ca12d; margin-right: 5px;"></div>
              <span>Ruta caminando</span>
            </div>
          `;
          container.appendChild(leyenda);
        }
        
        // Función para obtener y mostrar rutas caminando
        async function obtenerRutaCaminando(origen, destino, mapa, color, weight = 3, opacity = 0.8, tipo = 'origen') {
          // Forzar color morado oscuro si el color es azul
          if (color === '#007bff' || color === 'blue') color = '#6b46c1';
          const polyline = L.polyline([origen, destino], {
            color: color,
            weight: weight,
            opacity: opacity,
            dashArray: ''
          }).addTo(mapa);
          // Flecha grande a lo largo de toda la línea
          if (window.L && window.L.polylineDecorator) {
            L.polylineDecorator(polyline, {
              patterns: [
                {
                  offset: '0%',
                  repeat: 0,
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 48,
                    polygon: false,
                    pathOptions: {stroke: true, color: color, weight: weight + 2, opacity: 1}
                  })
                }
              ]
            }).addTo(mapa);
          }
        }
        
        // Crear mapas de paraderos cercanos
        console.log('🗺️ Iniciando creación de mapas...');
        await crearMapasParaderos(paraderosOrigen, paraderosDestino);
        console.log('✅ Mapas creados exitosamente');
        
        // Forzar redibujado de mapas después de un breve delay
        setTimeout(() => {
          const mapaOrigen = document.getElementById('mapa-origen');
          const mapaDestino = document.getElementById('mapa-destino');
          if (mapaOrigen && mapaOrigen._leaflet_map) {
            mapaOrigen._leaflet_map.invalidateSize();
          }
          if (mapaDestino && mapaDestino._leaflet_map) {
            mapaDestino._leaflet_map.invalidateSize();
          }
        }, 500);
        
        // =================== ACTIVAR NAVEGACIÓN INTELIGENTE ===================
        console.log('🧠 Activando navegación inteligente automáticamente...');
        
        // Verificar si tenemos coordenadas de destino válidas
        if (endCoords && Array.isArray(endCoords) && endCoords.length === 2) {
          console.log('✅ Coordenadas de destino válidas, iniciando navegación inteligente...');
          
          // Iniciar navegación inteligente automáticamente
          iniciarNavegacionInteligente(endCoords);
        } else {
          console.log('❌ No hay coordenadas de destino válidas para navegación inteligente');
          document.getElementById('info-ruta').innerHTML = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 1rem; color: #856404;"><strong>⚠️ Navegación Inteligente:</strong> No se pudo obtener las coordenadas de destino. Por favor, selecciona un destino válido.</div>';
        }
        
      } catch (error) {
        document.getElementById('info-paraderos').innerHTML = '<b>Error procesando la información:</b> ' + error.message;
      }
    }
    procesarInformacion();
    </script>
    <script>
    // Función para obtener la distancia caminando usando OpenRouteService
    async function obtenerDistanciaCaminando(origen, destino) {
      const apiKey = '5b3ce3597851110001cf6248e92a24fdb4744773ab33cab2c808de44';
      const url = `https://api.openrouteservice.org/v2/directions/foot-walking?api_key=${apiKey}`;
      // Log de depuración
      console.log('[DISTANCIA CAMINANDO] Enviando a ORS:', {
        origen, destino,
        origenLonLat: [origen[1], origen[0]],
        destinoLonLat: [destino[1], destino[0]]
      });
      const body = {
        coordinates: [
          [origen[1], origen[0]], // [lon, lat]
          [destino[1], destino[0]]
        ]
      };
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const data = await response.json();
        console.log('[DISTANCIA CAMINANDO] Respuesta ORS:', data);
        if (data && data.features && data.features[0]) {
          const distancia = data.features[0].properties.summary.distance;
          if (typeof distancia === 'number' && distancia > 0) {
            return distancia;
          }
        }
        // Si la API responde mal, usar fallback
        console.warn('[DISTANCIA CAMINANDO] ORS no devolvió distancia válida, usando haversine.');
        return haversine(origen[0], origen[1], destino[0], destino[1]);
      } catch (e) {
        console.error('Error consultando ORS:', e);
        // Fallback a haversine si hay error
        return haversine(origen[0], origen[1], destino[0], destino[1]);
      }
    }
    </script>
    <script>
    let paraderosAuto = [];
    fetch('paraderos.json')
      .then(res => res.json())
      .then(data => {
        paraderosAuto = data;
        inicializarAutocompletado('input-partida', 'sugerencias-partida', 'tuguia_start');
        inicializarAutocompletado('input-destino', 'sugerencias-destino', 'tuguia_end');
      });

    function inicializarAutocompletado(inputId, sugerenciasId, storageKey) {
      const input = document.getElementById(inputId);
      const sugerencias = document.getElementById(sugerenciasId);
      if (!input || !sugerencias) return;
      input.addEventListener('input', function() {
        const texto = input.value.toLowerCase();
        sugerencias.innerHTML = '';
        if (texto.length < 2) return;
        const resultados = paraderosAuto.filter(p => p.nombre.toLowerCase().includes(texto));
        resultados.forEach(p => {
          const div = document.createElement('div');
          div.textContent = p.nombre + ' - ' + p.direccion;
          div.style.cursor = 'pointer';
          div.style.padding = '0.3em 0.5em';
          div.onmouseover = () => div.style.background = '#f0f0ff';
          div.onmouseout = () => div.style.background = '#fff';
          div.onclick = () => {
            input.value = p.nombre;
            sugerencias.innerHTML = '';
            localStorage.setItem(storageKey, JSON.stringify({ nombre: p.nombre, coords: p.coords }));
            if (storageKey === 'tuguia_end') {
              localStorage.setItem('tuguia_end_mode', 'direccion');
            }
          };
          sugerencias.appendChild(div);
        });
      });
      input.addEventListener('blur', () => setTimeout(() => sugerencias.innerHTML = '', 200));
    }
    </script>
</div>
<footer class="footer-agapai">
  Desarrollado por <a href="https://brochure.agapai.com.co/" target="_blank">AGAPAI</a>
</footer>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const volverBtn = document.getElementById('volverAGuiaBtn');
  if (volverBtn) {
    volverBtn.addEventListener('click', function() {
      // Limpieza automática de datos de ruta antes de volver
      localStorage.removeItem('tuguia_start');
      localStorage.removeItem('tuguia_end');
      localStorage.removeItem('tuguia_start_mode');
      localStorage.removeItem('tuguia_end_mode');
      window.location.href = 'index.html';
    });
  }
});
</script>
<script>
// Limpieza automática de datos de ruta si el usuario navega hacia atrás (flecha del navegador)
window.addEventListener('pagehide', function(e) {
  // Si la navegación es hacia index.html (o cualquier salida de yotellevo.html)
  // Limpiar solo si la página se está ocultando porque el usuario navega (persisted = false)
  if (!e.persisted) {
    localStorage.removeItem('tuguia_start');
    localStorage.removeItem('tuguia_end');
    localStorage.removeItem('tuguia_start_mode');
    localStorage.removeItem('tuguia_end_mode');
  }
});
</script>
<script>
// Función para mostrar la alerta de proximidad (modal + notificación + vibración)
let alarmaProximidadInterval = null;
function mostrarAlertaProximidad() {
  // Mostrar modal llamativo
  var modal = document.getElementById('modal-proximidad');
  if (modal) modal.style.display = 'flex';

  // Iniciar alarma y vibración repetitiva (patrón MUY MOLESTO para despertar)
  detenerAlarmaProximidad(); // Por si acaso ya hay una activa
  alarmaProximidadInterval = setInterval(() => {
    // Vibración MUY AGRESIVA: vibrar 1500ms, pausa 100ms, repetir varias veces
    if (navigator.vibrate) navigator.vibrate([1500, 100, 1500, 100, 1500, 100, 1500, 100, 1500]);
    // Sonido MÁS CONTINUO Y RUIDOSO
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'square'; // Cambio a onda cuadrada para sonido más agresivo
      o.frequency.value = 660; // Frecuencia más baja para sonido más molesto
      o.connect(g); g.connect(ctx.destination);
      g.gain.value = 0.8; // VOLUMEN MUCHO MÁS ALTO (80%)
      o.start();
      setTimeout(()=>{g.gain.value=0; o.stop(); ctx.close();}, 800); // Sonido más largo
    } catch(e) {}
  }, 1500); // Intervalo más corto para sonido más continuo

  // Botón para detener alarma y vibración
  setTimeout(() => {
    const btn = document.getElementById('btnAlertaEntendido');
    if (btn) {
      btn.onclick = function() {
        detenerAlarmaProximidad();
        modal.style.display = 'none';
      };
    }
  }, 100);

  // Notificación del sistema (opcional, no bloquea la alarma/vibración)
  if (window.Notification && Notification.permission === 'granted') {
    new Notification('¡Faltan menos de 300 metros!', {
      body: 'Prepárate para descender en tu destino.',
      icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
    });
  } else if (window.Notification && Notification.permission !== 'denied') {
    Notification.requestPermission().then(function(permission) {
      if (permission === 'granted') {
        new Notification('¡Faltan menos de 300 metros!', {
          body: 'Prepárate para descender en tu destino.',
          icon: 'https://cdn-icons-png.flaticon.com/512/684/684908.png'
        });
      }
    });
  }
}

function detenerAlarmaProximidad() {
  if (alarmaProximidadInterval) {
    clearInterval(alarmaProximidadInterval);
    alarmaProximidadInterval = null;
  }
  if (navigator.vibrate) navigator.vibrate(0); // Detener vibración
}
    </script>
    <script>
    // Script adicional para asegurar que los mapas se carguen correctamente
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que los contenedores de mapas existan
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen) {
        console.log('✅ Contenedor mapa-origen encontrado');
      } else {
        console.error('❌ Contenedor mapa-origen no encontrado');
      }
      
      if (mapaDestino) {
        console.log('✅ Contenedor mapa-destino encontrado');
      } else {
        console.error('❌ Contenedor mapa-destino no encontrado');
      }
      
      // Verificar que Leaflet esté disponible
      if (typeof L !== 'undefined') {
        console.log('✅ Leaflet cargado correctamente');
      } else {
        console.error('❌ Leaflet no está disponible');
      }
    });
    
    // Función para forzar el redibujado de mapas
    function redibujarMapas() {
      const mapaOrigen = document.getElementById('mapa-origen');
      const mapaDestino = document.getElementById('mapa-destino');
      
      if (mapaOrigen && mapaOrigen._leaflet_map) {
        mapaOrigen._leaflet_map.invalidateSize();
        console.log('🔄 Mapa de origen redibujado');
      }
      
      if (mapaDestino && mapaDestino._leaflet_map) {
        mapaDestino._leaflet_map.invalidateSize();
        console.log('🔄 Mapa de destino redibujado');
      }
    }
    
    // Redibujar mapas cuando la ventana cambie de tamaño
    window.addEventListener('resize', redibujarMapas);
    
    // Redibujar mapas después de que la página se cargue completamente
    window.addEventListener('load', function() {
      setTimeout(redibujarMapas, 1000);
    });
    </script>
    <script>
    // --- FUNCIONES UTILITARIAS GLOBALES ---
    function limpiarDireccionParaMostrar(displayName) {
      if (!displayName) return '';
      const partes = displayName.split(',').map(s => s.trim());
      const irrelevantes = [
        'Cartagena de Indias',
        'Cartagena',
        'Bolivar',
        'Bolívar',
        '130003',
        'Dique',
        'Tierra Bomba',
        '130018',
        '130010',
        '130001',
        'Colombia',
        'Provincia',
        'Provincia de Cartagena'
      ];
      let partesFiltradas = partes.filter(parte => {
        const p = parte.toLowerCase().normalize('NFD').replace(/[0-\u036f]/g, '');
        return !irrelevantes.includes(parte) && !irrelevantes.includes(p);
      });
      // Elimina duplicados consecutivos
      partesFiltradas = partesFiltradas.filter((parte, idx, arr) => idx === 0 || parte !== arr[idx-1]);
      // Si al filtrar queda vacío, mostrar al menos el primer fragmento original
      if (partesFiltradas.length === 0 && partes.length > 0) {
        return partes[0];
      }
      return partesFiltradas.join(', ');
    }
    // ... el resto del código JS ...
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('🟣 [INIT] DOMContentLoaded en yotellevo.html');
      let start = localStorage.getItem('tuguia_start') || '';
      let end = localStorage.getItem('tuguia_end') || '';
      let startMode = localStorage.getItem('tuguia_start_mode') || '';
      let endMode = localStorage.getItem('tuguia_end_mode') || '';
      console.log('🟣 [INIT] Datos localStorage:', { start, end, startMode, endMode });

      function extraerCoords(str) {
        if (!str) return null;
        try {
          const obj = JSON.parse(str);
          if (obj && Array.isArray(obj.coords)) return obj.coords;
        } catch (e) {}
        let match = str.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
        if (match) return [parseFloat(match[1]), parseFloat(match[2])];
        return null;
      }

      let startCoords = extraerCoords(start);
      let endCoords = extraerCoords(end);
      console.log('🟣 [INIT] Coordenadas extraídas:', { startCoords, endCoords });

      if (!startCoords || !endCoords) {
        console.warn('🟣 [INIT] Faltan coordenadas de inicio o fin. No se puede mostrar el panel.');
        return;
      }

      try {
        // Simula el flujo de navegación inteligente
        console.log('🟣 [INIT] Llamando a iniciarNavegacionInteligente con:', endCoords);
        await iniciarNavegacionInteligente(endCoords);
        console.log('🟣 [INIT] Panel Tu Guía Inteligente debería mostrarse si todo fue bien.');
      } catch (error) {
        console.error('🟣 [INIT] Error al intentar mostrar el panel:', error);
      }
    });
    </script>
    <script>
    // === LÓGICA OPTIMIZADA DE MÚLTIPLES RUTAS ALTERNATIVAS ===
    async function calcularRutasAlternativas(startCoords, endCoords, paraderos) {
      // Evaluar más paraderos para encontrar más opciones
      let paraderosOrigen = paraderos.map(f => {
        let dist = haversine(startCoords[0], startCoords[1], f.lat, f.lon);
        return { ...f, dist };
      }).sort((a, b) => a.dist - b.dist).slice(0, 8); // Aumentado de 3 a 8
      
      let paraderosDestino = paraderos.map(f => {
        let dist = haversine(endCoords[0], endCoords[1], f.lat, f.lon);
        return { ...f, dist };
      }).sort((a, b) => a.dist - b.dist).slice(0, 8); // Aumentado de 3 a 8
      
      let todasLasRutas = [];
      
      for (let origen of paraderosOrigen) {
        for (let destino of paraderosDestino) {
          let caminataInicio = origen.dist;
          let caminataFin = destino.dist;
          
          // === RUTAS DIRECTAS ===
          let rutasComunes = origen.rutas.filter(r => destino.rutas.includes(r));
          if (rutasComunes.length > 0) {
            // Evaluar TODAS las rutas comunes, no solo la primera
            for (let ruta of rutasComunes) {
              let score = caminataInicio + caminataFin;
              todasLasRutas.push({
                tipo: 'directa',
                origen,
                destino,
                rutasBus: [ruta],
                caminataInicio,
                caminataFin,
                score,
                prioridad: score + (caminataInicio > 500 ? 200 : 0) // Penalizar caminatas largas
              });
            }
          }
          
          // === RUTAS CON TRANSBORDO ===
          for (let intermedio of paraderos) {
            if (intermedio === origen || intermedio === destino) continue;
            
            let rutas1 = origen.rutas.filter(r => intermedio.rutas.includes(r));
            let rutas2 = destino.rutas.filter(r => intermedio.rutas.includes(r));
            
            if (rutas1.length > 0 && rutas2.length > 0) {
              let distOrigenIntermedio = haversine(origen.lat, origen.lon, intermedio.lat, intermedio.lon);
              let distIntermedioDestino = haversine(intermedio.lat, intermedio.lon, destino.lat, destino.lon);
              
              // Evaluar combinaciones de rutas
              for (let ruta1 of rutas1) {
                for (let ruta2 of rutas2) {
                  if (ruta1 !== ruta2) { // Evitar transbordo innecesario
                    let score = caminataInicio + distOrigenIntermedio + distIntermedioDestino + caminataFin;
                    todasLasRutas.push({
                      tipo: 'transbordo',
                      origen,
                      destino,
                      intermedio,
                      rutasBus: [ruta1, ruta2],
                      caminataInicio,
                      caminataFin,
                      score,
                      prioridad: score + 100 // Penalizar transbordos
                    });
                  }
                }
              }
            }
          }
        }
      }
      
      // Ordenar por prioridad y eliminar duplicados
      todasLasRutas.sort((a, b) => a.prioridad - b.prioridad);
      
      // Eliminar rutas duplicadas (misma ruta, mismos paraderos)
      let rutasUnicas = [];
      let rutasVistas = new Set();
      
      for (let ruta of todasLasRutas) {
        let key = `${ruta.tipo}-${ruta.origen.nombre}-${ruta.destino.nombre}-${ruta.rutasBus.join(',')}`;
        if (!rutasVistas.has(key)) {
          rutasVistas.add(key);
          rutasUnicas.push(ruta);
        }
      }
      
      // Retornar las 5 mejores opciones
      return rutasUnicas.slice(0, 5);
    }
    
    // Función original mantenida para compatibilidad
    async function calcularRutaOptimaTotalmenteOptima(startCoords, endCoords, paraderos) {
      const rutasAlternativas = await calcularRutasAlternativas(startCoords, endCoords, paraderos);
      return rutasAlternativas.length > 0 ? rutasAlternativas[0] : null;
    }
    // === FIN LÓGICA OPTIMIZADA ===

    // ... dentro de procesarInformacion, después de filtrar/mapear paraderos ...
    const rutasAlternativas = await calcularRutasAlternativas(startCoords, endCoords, paraderos);
    if (rutasAlternativas && rutasAlternativas.length > 0) {
      let leyendaHTML = '<div style="background:#e6ffe6;border-left:5px solid #1ca12d;padding:1em;margin-bottom:1em;">';
      leyendaHTML += '<h4 style="margin:0 0 0.8em 0;color:#155724;">🚌 Rutas Disponibles:</h4>';
      
      rutasAlternativas.forEach((ruta, index) => {
        let opcionHTML = '';
        let icono = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '📋';
        let color = index === 0 ? '#155724' : '#6c757d';
        let bgColor = index === 0 ? '#d4edda' : '#f8f9fa';
        
        if (ruta.tipo === 'directa') {
          opcionHTML = `<strong>${ruta.rutasBus[0]}</strong> en <strong>${ruta.origen.nombre}</strong> hasta <strong>${ruta.destino.nombre}</strong>`;
        } else if (ruta.tipo === 'transbordo') {
          opcionHTML = `<strong>${ruta.rutasBus[0]}</strong> en <strong>${ruta.origen.nombre}</strong> → <strong>${ruta.intermedio.nombre}</strong> → <strong>${ruta.rutasBus[1]}</strong> hasta <strong>${ruta.destino.nombre}</strong>`;
        }
        
        if (endMode !== 'paradero') {
          opcionHTML += `<br><small>🚶 Caminata final: ${Math.round(ruta.caminataFin)}m</small>`;
        }
        
        leyendaHTML += `
          <div style="background:${bgColor};border-left:3px solid ${color};padding:0.8em;margin-bottom:0.5em;border-radius:4px;">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:0.3em;">
              <span style="font-size:1.2em;">${icono}</span>
              <strong style="color:${color};">Opción ${index + 1}</strong>
            </div>
            <div style="color:${color};font-size:0.95em;">${opcionHTML}</div>
          </div>
        `;
      });
      
      leyendaHTML += '</div>';
      document.getElementById('info-ruta').innerHTML = leyendaHTML;
      return;
    }
    // ... continuar con la lógica anterior si no hay rutas ...
    </script>
    <script>
    // ... después de await crearMapasParaderos(paraderosOrigen, paraderosDestino); ...
    // === DIBUJAR RECORRIDO EN BUS SOBRE LA RED DE TRANSCARIBE ===
    if (paraderosOrigen && paraderosOrigen.length > 0 && paraderosDestino && paraderosDestino.length > 0) {
      // Tomar el paradero más cercano de origen y destino
      const paraderoOrigenSeleccionado = paraderosOrigen[0];
      const paraderoDestinoSeleccionado = paraderosDestino[0];
      // Buscar la ruta oficial más cercana entre los paraderos
      if (typeof encontrarRutaOficialMasCercana === 'function') {
        const rutaOficial = encontrarRutaOficialMasCercana(
          [paraderoOrigenSeleccionado.lat, paraderoOrigenSeleccionado.lon],
          [paraderoDestinoSeleccionado.lat, paraderoDestinoSeleccionado.lon]
        );
        if (rutaOficial && rutaOficial.geometry && rutaOficial.geometry.coordinates) {
          // Dibujar la polilínea sobre la red de Transcaribe
          const coords = rutaOficial.geometry.coordinates.map(c => [c[1], c[0]]); // [lat, lng]
          if (typeof map !== 'undefined') {
            L.polyline(coords, { color: '#ff6600', weight: 6, opacity: 0.8 }).addTo(map);
          } else if (typeof mapaPrincipal !== 'undefined') {
            L.polyline(coords, { color: '#ff6600', weight: 6, opacity: 0.8 }).addTo(mapaPrincipal);
          }
        }
      }
    }
    // ...
    </script>
    <script>
    // === UTILIDAD PARA ENCONTRAR RUTA OFICIAL DE TRANSCARIBE ===
    function distanciaPuntoLinea(punto, linea) {
      // punto: [lat, lng], linea: array de [lng, lat]
      let minDist = Infinity;
      for (let i = 0; i < linea.length; i++) {
        const d = L.latLng(punto[0], punto[1]).distanceTo(L.latLng(linea[i][1], linea[i][0]));
        if (d < minDist) minDist = d;
      }
      return minDist;
    }

    function encontrarRutaOficialMasCercana(origen, destino) {
      // origen/destino: [lat, lng]
      if (!window.rutasTranscaribe) return null;
      let mejorRuta = null;
      let mejorScore = Infinity;
      let mejorSegmento = null;
      window.rutasTranscaribe.forEach(ruta => {
        const coords = ruta.geometry.coordinates;
        // Buscar el punto más cercano al origen
        let minDistOrigen = Infinity, idxOrigen = 0;
        for (let i = 0; i < coords.length; i++) {
          const d = L.latLng(origen[0], origen[1]).distanceTo(L.latLng(coords[i][1], coords[i][0]));
          if (d < minDistOrigen) { minDistOrigen = d; idxOrigen = i; }
        }
        // Buscar el punto más cercano al destino
        let minDistDestino = Infinity, idxDestino = 0;
        for (let i = 0; i < coords.length; i++) {
          const d = L.latLng(destino[0], destino[1]).distanceTo(L.latLng(coords[i][1], coords[i][0]));
          if (d < minDistDestino) { minDistDestino = d; idxDestino = i; }
        }
        const score = minDistOrigen + minDistDestino;
        if (score < mejorScore) {
          mejorScore = score;
          mejorRuta = ruta;
          // Extraer el segmento entre idxOrigen y idxDestino
          if (idxOrigen < idxDestino) {
            mejorSegmento = coords.slice(idxOrigen, idxDestino + 1);
          } else {
            mejorSegmento = coords.slice(idxDestino, idxOrigen + 1).reverse();
          }
        }
      });
      return mejorRuta && mejorSegmento ? { ruta: mejorRuta, segmento: mejorSegmento } : null;
    }
    // === FIN UTILIDAD ===
    </script>
</body>
</html> 